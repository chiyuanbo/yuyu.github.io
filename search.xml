<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>深入剖析volatile关键字</title>
      <link href="/2018/04/28/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/04/28/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<ul><li><a href="#一内存模型的相关概念">一.内存模型的相关概念</a></li><li><a href="#二并发编程中的三个概念">二.并发编程中的三个概念</a><ul><li><a href="#1原子性">1.原子性</a></li><li><a href="#2可见性">2.可见性</a></li><li><a href="#3有序性">3.有序性</a></li></ul></li><li><a href="#三java内存模型">三.Java内存模型</a><ul><li><a href="#1原子性">1.原子性</a></li><li><a href="#2可见性">2.可见性</a></li><li><a href="#3有序性">3.有序性</a></li></ul></li><li><a href="#四深入剖析volatile关键字">四.深入剖析volatile关键字</a><ul><li><a href="#1volatile关键字的两层语义">1.volatile关键字的两层语义</a></li><li><a href="#2volatile保证原子性吗">2.volatile保证原子性吗？</a></li><li><a href="#3volatile能保证有序性吗">3.volatile能保证有序性吗？</a></li></ul></li><li><a href="#五使用volatile关键字的场景">五.使用volatile关键字的场景</a><ul><li><a href="#1状态标记量">1.状态标记量</a></li><li><a href="#2double-check">2.double check</a></li></ul></li></ul><p>&emsp;&emsp;volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p><p>&emsp;&emsp;volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p><h3 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h3><p>&emsp;&emsp;大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p><p>&emsp;&emsp;也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p><pre><code>i = i + 1;  </code></pre><p>&emsp;&emsp;当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>&emsp;&emsp;这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p><p>&emsp;&emsp;比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p><p>&emsp;&emsp;可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p>&emsp;&emsp;最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>　　<br>&emsp;&emsp;也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>&emsp;&emsp;为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><p>&emsp;&emsp;1）通过在总线加LOCK#锁的方式</p><p>&emsp;&emsp;2）通过缓存一致性协议</p><p>&emsp;&emsp;这2种方式都是硬件层面上提供的方式。</p><p>&emsp;&emsp;在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p><p>&emsp;&emsp;但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>&emsp;&emsp;所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。<br><img src="http://i1.piimg.com/567571/2c8fdb86b1860315.jpg" alt=""></p><h3 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h3><pre><code>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</code></pre><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h4><p>&emsp;&emsp;原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>&emsp;&emsp;一个很经典的例子就是银行账户转账问题：</p><p>&emsp;&emsp;比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p><p>&emsp;&emsp;试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p><p>&emsp;&emsp;所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p><p>&emsp;&emsp;同样地反映到并发编程中会出现什么结果呢？</p><p>&emsp;&emsp;举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p><pre><code>i = 9;  </code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p><p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。           </p><h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码  </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">i = <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码  </span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>&emsp;&emsp;此时线程2执行 j =i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>&emsp;&emsp;这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>&emsp;&emsp;有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;                </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1    </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p>&emsp;&emsp;下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>&emsp;&emsp;比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p><p>&emsp;&emsp;但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1  </span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2  </span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3  </span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>这段代码有4个语句，那么可能的一个执行顺序是：</p><p><img src="http://i2.muimg.com/567571/57f70712db840e39.jpg" alt=""><br>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p><p>&emsp;&emsp;不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p><p>&emsp;&emsp;虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:  </span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1  </span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:  </span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;  </span><br><span class="line">  sleep()  </span><br><span class="line">&#125;  </span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>&emsp;&emsp;从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p><p>&emsp;&emsp;也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h3 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h3><p>&emsp;&emsp;在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p><p>&emsp;&emsp;在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p>&emsp;&emsp;Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p><p>&emsp;&emsp;举个简单的例子：在java中，执行下面这个语句：</p><pre><code>i  = 10;  </code></pre><p>&emsp;&emsp;执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>&emsp;&emsp;那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p><h4 id="1-原子性-1"><a href="#1-原子性-1" class="headerlink" title="1.原子性"></a>1.原子性</h4><p>&emsp;&emsp;在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>&emsp;&emsp;上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：<br>　　请分析以下哪些操作是原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1  </span></span><br><span class="line">y = x;         <span class="comment">//语句2  </span></span><br><span class="line">x++;           <span class="comment">//语句3  </span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p><p>&emsp;&emsp;语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p><p>&emsp;&emsp;语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p><p>&emsp;&emsp;同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p><p>&emsp;&emsp;所以上面4个语句只有语句1的操作具备原子性。</p><p>&emsp;&emsp;也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><p>&emsp;&emsp;不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p><p>&emsp;&emsp;从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h4 id="2-可见性-1"><a href="#2-可见性-1" class="headerlink" title="2.可见性"></a>2.可见性</h4><p>&emsp;&emsp;对于可见性，Java提供了volatile关键字来保证可见性。</p><p>&emsp;&emsp;当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>&emsp;&emsp;而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>&emsp;&emsp;另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h4 id="3-有序性-1"><a href="#3-有序性-1" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>&emsp;&emsp;在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>&emsp;&emsp;在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>&emsp;&emsp;另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p><p>&emsp;&emsp;下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<ul><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul></li></ul><p>&emsp;&emsp;这8条原则摘自《深入理解Java虚拟机》。</p><p>&emsp;&emsp;这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p><p>&emsp;&emsp;下面我们来解释一下前4条规则：</p><p>&emsp;&emsp;对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p><p>&emsp;&emsp;第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p><p>&emsp;&emsp;第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p><p>&emsp;&emsp;第四条规则实际上就是体现happens-before原则具备传递性。</p><h3 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h3><p>&emsp;&emsp;在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p><h4 id="1-volatile关键字的两层语义"><a href="#1-volatile关键字的两层语义" class="headerlink" title="1.volatile关键字的两层语义"></a>1.volatile关键字的两层语义</h4><p>&emsp;&emsp;一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><pre><code>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。</code></pre><p>&emsp;&emsp;先看一段代码，假如线程1先执行，线程2后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1  </span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;  </span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;  </span><br><span class="line">doSomething();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2  </span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><p>&emsp;&emsp;下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p><p>&emsp;&emsp;那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p><p>&emsp;&emsp;但是用volatile修饰之后就变得不一样了：</p><p>&emsp;&emsp;第一：使用volatile关键字会强制将修改的值立即写入主存；</p><p>&emsp;&emsp;第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>&emsp;&emsp;第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p><p>&emsp;&emsp;那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p><p>&emsp;&emsp;那么线程1读取到的就是最新的正确的值。</p><h4 id="2-volatile保证原子性吗？"><a href="#2-volatile保证原子性吗？" class="headerlink" title="2.volatile保证原子性吗？"></a>2.volatile保证原子性吗？</h4><p>&emsp;&emsp;从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>　　<br>&emsp;&emsp;下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">inc++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line"><span class="keyword">new</span> Thread()&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">test.increase();  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;.start();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">Thread.yield();  </span><br><span class="line">System.out.println(test.inc);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p><p>&emsp;&emsp;可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p><p>&emsp;&emsp;这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p><p>&emsp;&emsp;在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>&emsp;&emsp;假如某个时刻变量inc的值为10，</p><p>&emsp;&emsp;线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p><p>&emsp;&emsp;然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><p>&emsp;&emsp;然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p><p>&emsp;&emsp;那么两个线程分别进行了一次自增操作后，inc只增加了1。</p><p>&emsp;&emsp;解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p><p>&emsp;&emsp;根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p><p>&emsp;&emsp;把上面的代码改成以下任何一种都可以达到效果：</p><p>&emsp;&emsp;采用synchronized：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">inc++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line"><span class="keyword">new</span> Thread()&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">test.increase();  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;.start();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">Thread.yield();  </span><br><span class="line">System.out.println(test.inc);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;采用Lock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;  </span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">lock.lock();  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">inc++;  </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;  </span><br><span class="line">lock.unlock();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line"><span class="keyword">new</span> Thread()&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">test.increase();  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;.start();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">Thread.yield();  </span><br><span class="line">System.out.println(test.inc);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;采用AtomicInteger：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line"><span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">inc.getAndIncrement();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line"><span class="keyword">new</span> Thread()&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">test.increase();  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;.start();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">Thread.yield();  </span><br><span class="line">System.out.println(test.inc);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p><h4 id="3-volatile能保证有序性吗？"><a href="#3-volatile能保证有序性吗？" class="headerlink" title="3.volatile能保证有序性吗？"></a>3.volatile能保证有序性吗？</h4><p>&emsp;&emsp;在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>&emsp;&emsp;volatile关键字禁止指令重排序有两层意思：</p><pre><code>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</code></pre><p>&emsp;&emsp;可能上面说的比较绕，举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量  </span></span><br><span class="line"><span class="comment">//flag为volatile变量  </span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1  </span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2  </span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3  </span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4  </span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>&emsp;&emsp;并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>&emsp;&emsp;那么我们回到前面举的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:  </span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1  </span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:  </span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;  </span><br><span class="line">  sleep()  </span><br><span class="line">&#125;  </span><br><span class="line">doSomethingwithconfig(context);  </span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;前面举这个例子的时候，提到有可能语句<span class="number">2</span>会在语句<span class="number">1</span>之前执行，那么就可能导致context还没被初始化，而线程<span class="number">2</span>中就使用未初始化的context去进行操作，导致程序出错。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;这里如果用<span class="keyword">volatile</span>关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句<span class="number">2</span>时，必定能保证context已经初始化完毕。</span><br><span class="line"><span class="number">4</span>.<span class="keyword">volatile</span>的原理和实现机制</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;前面讲述了源于<span class="keyword">volatile</span>关键字的一些使用，下面我们来探讨一下<span class="keyword">volatile</span>到底如何保证可见性和禁止指令重排序的。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;下面这段话摘自《深入理解Java虚拟机》：</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;“观察加入<span class="keyword">volatile</span>关键字和没有加入<span class="keyword">volatile</span>关键字时所生成的汇编代码发现，加入<span class="keyword">volatile</span>关键字时，会多出一个lock前缀指令”</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供<span class="number">3</span>个功能：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</span><br><span class="line">    <span class="number">2</span>）它会强制将对缓存的修改操作立即写入主存；</span><br><span class="line">    <span class="number">3</span>）如果是写操作，它会导致其他CPU中对应的缓存行无效。</span><br><span class="line">### 五.使用volatile关键字的场景</span><br><span class="line">&amp;emsp;&amp;emsp;<span class="keyword">synchronized</span>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<span class="keyword">volatile</span>关键字在某些情况下性能要优于<span class="keyword">synchronized</span>，但是要注意<span class="keyword">volatile</span>关键字是无法替代<span class="keyword">synchronized</span>关键字的，因为<span class="keyword">volatile</span>关键字无法保证操作的原子性。通常来说，使用<span class="keyword">volatile</span>必须具备以下<span class="number">2</span>个条件：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>）对变量的写操作不依赖于当前值</span><br><span class="line">    <span class="number">2</span>）该变量没有包含在具有其他变量的不变式中</span><br><span class="line">&amp;emsp;&amp;emsp;实际上，这些条件表明，可以被写入 <span class="keyword">volatile</span> 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;事实上，我的理解就是上面的<span class="number">2</span>个条件需要保证操作是原子性操作，才能保证使用<span class="keyword">volatile</span>关键字的程序在并发时能够正确执行。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;下面列举几个Java中使用<span class="keyword">volatile</span>的几个场景。</span><br><span class="line"></span><br><span class="line">#### 1.状态标记量</span><br><span class="line"></span><br><span class="line">````java</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;  </span><br><span class="line">doSomething();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">flag = <span class="keyword">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;  </span><br><span class="line"><span class="comment">//线程1:  </span></span><br><span class="line">context = loadContext();    </span><br><span class="line">inited = <span class="keyword">true</span>;              </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:  </span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;  </span><br><span class="line">sleep()  </span><br><span class="line">&#125;  </span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><h4 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;  </span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line"><span class="keyword">if</span>(instance==<span class="keyword">null</span>)  </span><br><span class="line">instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> instance;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;于为何;需要这么写请参考：</p><p>&emsp;&emsp;《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024和http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://blog.csdn.net/dl88250/article/details/5439024和http://www.iteye.com/topic/652440</a></p><p>&emsp;&emsp;参考资料：<br>　　《深入理解Java虚拟机》</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>枚举实现单例连接数据库</title>
      <link href="/2018/04/28/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/04/28/%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>创建一个jdbc.propertis文件，其内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driverClass = com.mysql.jdbc.Driver</span><br><span class="line">jdbcUrl = jdbc:mysql:<span class="comment">//localhost:3306/liaokailin</span></span><br><span class="line">user = root</span><br><span class="line">password = mysqladmin</span><br><span class="line">maxPoolSize = <span class="number">20</span></span><br><span class="line">minPoolSize = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>创建一个MyDataBaseSource的枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MyDataBaseSource &#123;</span><br><span class="line">DATASOURCE;</span><br><span class="line"><span class="keyword">private</span> ComboPooledDataSource cpds = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyDataBaseSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*--------获取properties文件内容------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * InputStream is =</span></span><br><span class="line"><span class="comment"> * MyDBSource.class.getClassLoader().getResourceAsStream("jdbc.properties");</span></span><br><span class="line"><span class="comment"> * Properties p = new Properties(); p.load(is);</span></span><br><span class="line"><span class="comment"> * System.out.println(p.getProperty("driverClass") );</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：(不需要properties的后缀)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ResourceBundle rb = PropertyResourceBundle.getBundle("jdbc") ;</span></span><br><span class="line"><span class="comment"> * System.out.println(rb.getString("driverClass"));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：(不需要properties的后缀)</span></span><br><span class="line">ResourceBundle rs = ResourceBundle.getBundle(<span class="string">"jdbc"</span>);</span><br><span class="line">cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass(rs.getString(<span class="string">"driverClass"</span>));</span><br><span class="line">cpds.setJdbcUrl(rs.getString(<span class="string">"jdbcUrl"</span>));</span><br><span class="line">cpds.setUser(rs.getString(<span class="string">"user"</span>));</span><br><span class="line">cpds.setPassword(rs.getString(<span class="string">"password"</span>));</span><br><span class="line">cpds.setMaxPoolSize(Integer.parseInt(rs.getString(<span class="string">"maxPoolSize"</span>)));</span><br><span class="line">cpds.setMinPoolSize(Integer.parseInt(rs.getString(<span class="string">"minPoolSize"</span>)));    </span><br><span class="line"> System.out.println(<span class="string">"-----调用了构造方法------"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cpds.getConnection();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyDataBaseSource.DATASOURCE.getConnection() ;</span><br><span class="line">MyDataBaseSource.DATASOURCE.getConnection() ;</span><br><span class="line">MyDataBaseSource.DATASOURCE.getConnection() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----调用了构造方法------</span><br><span class="line"><span class="number">2013</span>-<span class="number">7</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">10</span>:<span class="number">57</span> com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource getPoolManager</span><br><span class="line">信息: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -&gt; <span class="number">3</span>, acquireRetryAttempts -&gt; <span class="number">30</span>, acquireRetryDelay -&gt; <span class="number">1000</span>, autoCommitOnClose -&gt; <span class="keyword">false</span>, automaticTestTable -&gt; <span class="keyword">null</span>, breakAfterAcquireFailure -&gt; <span class="keyword">false</span>, checkoutTimeout -&gt; <span class="number">0</span>, connectionCustomizerClassName -&gt; <span class="keyword">null</span>, connectionTesterClassName -&gt; com.mchange.v2.c3p0.impl.DefaultConnectionTester, dataSourceName -&gt; <span class="number">1</span>hge16d8v1tgb0wppydrzz|<span class="number">2</span>c1e6b, debugUnreturnedConnectionStackTraces -&gt; <span class="keyword">false</span>, description -&gt; <span class="keyword">null</span>, driverClass -&gt; com.mysql.jdbc.Driver, factoryClassLocation -&gt; <span class="keyword">null</span>, forceIgnoreUnresolvedTransactions -&gt; <span class="keyword">false</span>, identityToken -&gt; <span class="number">1</span>hge16d8v1tgb0wppydrzz|<span class="number">2</span>c1e6b, idleConnectionTestPeriod -&gt; <span class="number">0</span>, initialPoolSize -&gt; <span class="number">3</span>, jdbcUrl -&gt; jdbc:mysql:<span class="comment">//localhost:3306/kaoqin, maxAdministrativeTaskTime -&gt; 0, maxConnectionAge -&gt; 0, maxIdleTime -&gt; 0, maxIdleTimeExcessConnections -&gt; 0, maxPoolSize -&gt; 20, maxStatements -&gt; 0, maxStatementsPerConnection -&gt; 0, minPoolSize -&gt; 5, numHelperThreads -&gt; 3, preferredTestQuery -&gt; null, properties -&gt; &#123;user=******, password=******&#125;, propertyCycle -&gt; 0, statementCacheNumDeferredCloseThreads -&gt; 0, testConnectionOnCheckin -&gt; false, testConnectionOnCheckout -&gt; false, unreturnedConnectionTimeout -&gt; 0, usesTraditionalReflectiveProxies -&gt; false ]</span></span><br></pre></td></tr></table></figure></p><p>很显然获得了三个Connection连接，但是只调用了一次枚举的构造方法,从而通过枚举实现了单例的设计</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决maven依赖</title>
      <link href="/2018/04/28/%E8%A7%A3%E5%86%B3maven%E4%BE%9D%E8%B5%96/"/>
      <url>/2018/04/28/%E8%A7%A3%E5%86%B3maven%E4%BE%9D%E8%B5%96/</url>
      <content type="html"><![CDATA[<p>[toc]</p><p>依赖过滤</p><p>（1）单依赖过滤</p><pre><code>同依赖过滤直接处理：可以过滤一个或者多个，如果过滤多个要写多个&lt;exclusion&gt;。这个也解决不了我的问题，或者说解决太麻烦，我那里知道hbase要依赖那些包，记不住。</code></pre><p>Java代码  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.94.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>    </span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>        </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）多依赖过滤</p><pre><code>把所以依赖都过滤了。手起刀落~啊，世界都安静了。</code></pre><p>Java代码  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.94.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编码与乱码</title>
      <link href="/2018/04/28/%E7%BC%96%E7%A0%81%E4%B8%8E%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/04/28/%E7%BC%96%E7%A0%81%E4%B8%8E%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="乱码的根源"><a href="#乱码的根源" class="headerlink" title="乱码的根源"></a>乱码的根源</h3><p>源编码与目标编码的不一致. 而中文window系统默认编码GBK,害惨了多少程序员.</p><p>要尽量减少出现乱码,我个人认为要做到5码合一, IDE(Eclipse/idea),页面(jsp/其他模板引擎),应用服务器(tomcat等), 源码(Java源码及周边文件),数据库编码.</p><h3 id="将Eclipse设置为UTF-8"><a href="#将Eclipse设置为UTF-8" class="headerlink" title="将Eclipse设置为UTF-8"></a>将Eclipse设置为UTF-8</h3><p>打开Eclipse安装目录下的eclipse.ini,在最末尾新增一行</p><pre><code>-Dfile.encoding=UTF-8</code></pre><p>修改之后的,重启eclipse即可.</p><h3 id="JSP页面编码"><a href="#JSP页面编码" class="headerlink" title="JSP页面编码"></a>JSP页面编码</h3><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;可以设置eclipse的jsp设置</code></pre><h3 id="tomcat编码"><a href="#tomcat编码" class="headerlink" title="tomcat编码"></a>tomcat编码</h3><p>打开 tomcat安装目录下的 binsetenv.bat ,该文件通常不存在,新建之, 添加如下内容</p><pre><code>set JAVA_OPTS=-Dfile.encoding=UTF-8</code></pre><p>打开confserver.conf, 在8080端口所属的Connector节点,添加URIEncoding,可解决大部分GET请求中文乱码的问题</p><pre><code>URIEncoding=&quot;UTF-8&quot;</code></pre><h3 id="源码的编码"><a href="#源码的编码" class="headerlink" title="源码的编码"></a>源码的编码</h3><p>通常情况下, 文件本身的编码,取决于新建文件时,IDE或Project的编码.</p><p>另外一个隐藏的编码,是maven/ant编译java源文件时使用的编码</p><p>maven的配置如下</p><pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</code></pre><h3 id="数据库编码"><a href="#数据库编码" class="headerlink" title="数据库编码"></a>数据库编码</h3><p>通常来说,如果其他4码解决了,那大部分情况下是mysql会出现编码问题</p><p>mysql有4个编码</p><pre><code>Server characterset:    utf8      // 服务器字节集Db     characterset:    utf8      // 当前数据集字节集Client characterset:    utf8      // 客户端字节集Conn.  characterset:    utf8      // 当前连接的字节集</code></pre><p>修改my.ini的mysqld小节,设置服务器字符集,是最佳解决方式</p><pre><code>[mysqld]character-set-server = utf8</code></pre><p>然而,对于现有系统,全局修改的风险比较大,所以,可以在客户端解决,即jdbcurl上做配置</p><pre><code>jdbc:mysql://127.0.0.1/nutzdemo?useUnicode=true&amp;characterEncoding=UTF-8</code></pre><h3 id="Nutz的相关日志"><a href="#Nutz的相关日志" class="headerlink" title="Nutz的相关日志"></a>Nutz的相关日志</h3><p>nutz在启动时也会打印周围的编码信息,帮助排查.</p><pre><code>21:22:23.235 INFO  (NutLoading.java:55) load - Nutz Version : 1.r.59 21:22:23.235 INFO  (NutLoading.java:56) load - Nutz.Mvc[nutz] is initializing ...21:22:23.235 DEBUG (NutLoading.java:60) load - Web Container Information:21:22:23.237 DEBUG (NutLoading.java:61) load -  - Default Charset : UTF-821:22:23.237 DEBUG (NutLoading.java:62) load -  - Current . path  : D:\nutzbook\eclipse\.21:22:23.237 DEBUG (NutLoading.java:63) load -  - Java Version    : 1.8.0_11221:22:23.237 DEBUG (NutLoading.java:65) load -  - Timezone        : Asia/Shanghai21:22:23.238 DEBUG (NutLoading.java:66) load -  - OS              : Windows 7 amd6421:22:23.238 DEBUG (NutLoading.java:67) load -  - ServerInfo      : Apache Tomcat/9.0.0.M1321:22:23.238 DEBUG (NutLoading.java:68) load -  - Servlet API     : 4.021:22:23.238 DEBUG (NutLoading.java:73) load -  - ContextPath     : /nutzbook21:22:25.134 DEBUG (DaoSupport.java:199) invoke - JDBC Name   --&gt; MySQL Connector Java21:22:25.135 DEBUG (DaoSupport.java:201) invoke - JDBC URL    --&gt; jdbc:mysql://127.0.0.1:3306/nutzbook21:22:25.145 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_client=utf821:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_connection=utf821:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_database=utf821:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_filesystem=binary21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_results=21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_server=utf821:22:25.147 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_system=utf8</code></pre><p>Default Charset的编码,在Eclipse环境内, 通过eclipse.ini调整,在tomcat内的话,通过setenv.bat调整.</p><p>mysql的编码,通过修改my.ini或jdbc url进行调整</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql</title>
      <link href="/2018/04/28/sql/"/>
      <url>/2018/04/28/sql/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h4 id="时间分区表查询出指定日期-精确到天-的数据量"><a href="#时间分区表查询出指定日期-精确到天-的数据量" class="headerlink" title="时间分区表查询出指定日期(精确到天)的数据量"></a>时间分区表查询出指定日期(精确到天)的数据量</h4><p>数据库有一列为</p><p><img src="https://ooo.0o0.ooo/2017/06/02/5930dc8090c95.png" alt="下载.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select count(*) from "</span>+libraryName+<span class="string">"."</span>+schemaName+<span class="string">"."</span> +tableName+<span class="string">" where to_char(OCCUR_TIME,'yyyy-mm-dd')='"</span>+dateStr+<span class="string">"'"</span>;</span><br></pre></td></tr></table></figure><h4 id="小松鼠执行hive-sql的时候出现missing-EFO-near…"><a href="#小松鼠执行hive-sql的时候出现missing-EFO-near…" class="headerlink" title="小松鼠执行hive sql的时候出现missing EFO near…"></a>小松鼠执行hive sql的时候出现missing EFO near…</h4><p>注意sql栏的状态是否上边藏了几个sql，有的话清掉。</p><h4 id="Hbase的sql时间查询-查询某天的-HAPPENTIME类型为-TIMESTAMP"><a href="#Hbase的sql时间查询-查询某天的-HAPPENTIME类型为-TIMESTAMP" class="headerlink" title="Hbase的sql时间查询  查询某天的 HAPPENTIME类型为:TIMESTAMP"></a>Hbase的sql时间查询  查询某天的 HAPPENTIME类型为:TIMESTAMP</h4><pre><code>select * from FJUDM4.HBASE_MD_OMS_T_COMBINEMONITOR_BUG where HAPPENTIME&gt;=to_date(&apos;2016-10-12 00:00:00&apos;) and HAPPENTIME&lt;to_date(&apos;2016-10-13 00:00:00&apos;)</code></pre><p><img src="https://ooo.0o0.ooo/2017/06/02/5930dc8079553.png" alt="下载 (1).png"></p><h4 id="hive的sql时间分区查询"><a href="#hive的sql时间分区查询" class="headerlink" title="hive的sql时间分区查询"></a>hive的sql时间分区查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from fjudm4.hbase_md_all_op_ctrl where occur_time &gt;= <span class="number">2016</span>-<span class="number">11</span>-<span class="number">01</span> and occur_time &lt; <span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span></span><br><span class="line">没有加单引号报错</span><br><span class="line"></span><br><span class="line">select * from fjudm4.hbase_md_all_op_ctrl where occur_time = <span class="string">'2016-11-01'</span></span><br><span class="line">不可以直接用=</span><br><span class="line"></span><br><span class="line">select * from fjudm4.hbase_md_all_op_ctrl where occur_time &gt;= <span class="string">'2016-11-01'</span> and occur_time &lt; <span class="string">'2016-11-02'</span></span><br><span class="line">正确语法</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spark学习记录</title>
      <link href="/2018/04/28/spark%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/04/28/spark%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p> 用spark-submit命令提交任务运行，具体使用查看：spark-submit –help</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  --master MASTER_URL         spark:<span class="comment">//host:port, mesos://host:port, yarn, or local.</span></span><br><span class="line">  --deploy-<span class="function">mode DEPLOY_MODE   Whether to launch the driver program <span class="title">locally</span> <span class="params">(<span class="string">"client"</span>)</span> or</span></span><br><span class="line"><span class="function">                              on one of the worker machines inside the <span class="title">cluster</span> <span class="params">(<span class="string">"cluster"</span>)</span></span></span><br><span class="line"><span class="function">                              <span class="params">(Default: client)</span>.</span></span><br><span class="line"><span class="function">  --class CLASS_NAME          Your application's main <span class="title">class</span> <span class="params">(<span class="keyword">for</span> Java / Scala apps)</span>.</span></span><br><span class="line"><span class="function">  --name NAME                 A name of your application.</span></span><br><span class="line"><span class="function">  --jars JARS                 Comma-separated list of local jars to include on the driver</span></span><br><span class="line"><span class="function">                              and executor classpaths.</span></span><br><span class="line"><span class="function">  --packages                  Comma-separated list of maven coordinates of jars to include</span></span><br><span class="line"><span class="function">                              on the driver and executor classpaths. Will search the local</span></span><br><span class="line"><span class="function">                              maven repo, then maven central and any additional remote</span></span><br><span class="line"><span class="function">                              repositories given by --repositories. The format <span class="keyword">for</span> the</span></span><br><span class="line"><span class="function">                              coordinates should be groupId:artifactId:version.</span></span><br><span class="line"><span class="function">  --exclude-packages          Comma-separated list of groupId:artifactId, to exclude <span class="keyword">while</span></span></span><br><span class="line"><span class="function">                              resolving the dependencies provided in --packages to avoid</span></span><br><span class="line"><span class="function">                              dependency conflicts.</span></span><br><span class="line"><span class="function">  --repositories              Comma-separated list of additional remote repositories to</span></span><br><span class="line"><span class="function">                              search <span class="keyword">for</span> the maven coordinates given with --packages.</span></span><br><span class="line"><span class="function">  --py-files PY_FILES         Comma-separated list of .zip, .egg, or .py files to place</span></span><br><span class="line"><span class="function">                              on the PYTHONPATH <span class="keyword">for</span> Python apps.</span></span><br><span class="line"><span class="function">  --files FILES               Comma-separated list of files to be placed in the working</span></span><br><span class="line"><span class="function">                              directory of each executor.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --conf PROP</span>=VALUE           Arbitrary Spark configuration property.</span><br><span class="line">  --properties-file FILE      Path to a file from which to load extra properties. If not</span><br><span class="line">                              specified, <span class="keyword">this</span> will look <span class="keyword">for</span> conf/spark-defaults.conf.</span><br><span class="line"></span><br><span class="line">  --driver-<span class="function">memory MEM         Memory <span class="keyword">for</span> <span class="title">driver</span> <span class="params">(e.g. <span class="number">1000</span>M, <span class="number">2</span>G)</span> <span class="params">(Default: <span class="number">1024</span>M)</span>.</span></span><br><span class="line"><span class="function">  --driver-java-options       Extra Java options to pass to the driver.</span></span><br><span class="line"><span class="function">  --driver-library-path       Extra library path entries to pass to the driver.</span></span><br><span class="line"><span class="function">  --driver-class-path         Extra class path entries to pass to the driver. Note that</span></span><br><span class="line"><span class="function">                              jars added with --jars are automatically included in the</span></span><br><span class="line"><span class="function">                              classpath.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --executor-memory MEM       Memory per <span class="title">executor</span> <span class="params">(e.g. <span class="number">1000</span>M, <span class="number">2</span>G)</span> <span class="params">(Default: <span class="number">1</span>G)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --proxy-user NAME           User to impersonate when submitting the application.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --help, -h                  Show <span class="keyword">this</span> help message and exit</span></span><br><span class="line"><span class="function">  --verbose, -v               Print additional debug output</span></span><br><span class="line"><span class="function">  --version,                  Print the version of current Spark</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone with cluster deploy mode only:</span></span><br><span class="line"><span class="function">  --driver-cores NUM          Cores <span class="keyword">for</span> <span class="title">driver</span> <span class="params">(Default: <span class="number">1</span>)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone or Mesos with cluster deploy mode only:</span></span><br><span class="line"><span class="function">  --supervise                 If given, restarts the driver on failure.</span></span><br><span class="line"><span class="function">  --kill SUBMISSION_ID        If given, kills the driver specified.</span></span><br><span class="line"><span class="function">  --status SUBMISSION_ID      If given, requests the status of the driver specified.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone and Mesos only:</span></span><br><span class="line"><span class="function">  --total-executor-cores NUM  Total cores <span class="keyword">for</span> all executors.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone and YARN only:</span></span><br><span class="line"><span class="function">  --executor-cores NUM        Number of cores per executor. <span class="params">(Default: <span class="number">1</span> in YARN mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                              or all available cores on the worker in standalone mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> YARN-only:</span></span><br><span class="line"><span class="function">  --driver-cores NUM          Number of cores used by the driver, only in cluster mode</span></span><br><span class="line"><span class="function">                              <span class="params">(Default: <span class="number">1</span>)</span>.</span></span><br><span class="line"><span class="function">  --queue QUEUE_NAME          The YARN queue to submit <span class="title">to</span> <span class="params">(Default: <span class="string">"default"</span>)</span>.</span></span><br><span class="line"><span class="function">  --num-executors NUM         Number of executors to <span class="title">launch</span> <span class="params">(Default: <span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">  --archives ARCHIVES         Comma separated list of archives to be extracted into the</span></span><br><span class="line"><span class="function">                              working directory of each executor.</span></span><br><span class="line"><span class="function">  --principal PRINCIPAL       Principal to be used to login to KDC, <span class="keyword">while</span> running on</span></span><br><span class="line"><span class="function">                              secure HDFS.</span></span><br><span class="line"><span class="function">  --keytab KEYTAB             The full path to the file that contains the keytab <span class="keyword">for</span> the</span></span><br><span class="line"><span class="function">                              principal specified above. This keytab will be copied to</span></span><br><span class="line"><span class="function">                              the node running the Application Master via the Secure</span></span><br><span class="line"><span class="function">                              Distributed Cache, <span class="keyword">for</span> renewing the login tickets and the</span></span><br><span class="line"><span class="function">                              delegation tokens periodically.</span></span><br></pre></td></tr></table></figure><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p> Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient resources</p><pre><code>当前的集群的可用资源不能满足应用程序所请求的资源。我spark submit的时候给的资源太大了资源分2类： cores 和 ramCore代表对执行可用的executor slotsRam代表每个Worker上被需要的空闲内存来运行你的Application。解决方法：应用不要请求多余空闲可用资源的关闭掉已经执行结束的Application</code></pre><h3 id="spark-submit执行命令"><a href="#spark-submit执行命令" class="headerlink" title="spark-submit执行命令"></a>spark-submit执行命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master spark:<span class="comment">//FJ-DCLOUD-HDP01:7077 --conf "spark.scheduler.mode=FAIR" --total-executor-cores 8 --driver-memory 20g --executor-memory 20g /home/yarn/dev/cyb/a.jar </span></span><br><span class="line"></span><br><span class="line">a.jar不需要jar包   所要用的jar包放到spark服务器的lib下  例如：</span><br><span class="line">/home/yarn/spark-<span class="number">1.5</span>.2-bin-hadoop2.6/lib</span><br><span class="line">命令会默认读取改路径下的jar</span><br><span class="line">关于此设置的配置 见下条</span><br></pre></td></tr></table></figure><h3 id="spark-submit指定服务器jar包配置"><a href="#spark-submit指定服务器jar包配置" class="headerlink" title="spark-submit指定服务器jar包配置"></a>spark-submit指定服务器jar包配置</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[yarn@EPRI-DCLOUD-ETL01 conf]$ pwd</span><br><span class="line">/home/yarn/spark-<span class="number">1.5</span>.<span class="number">2</span>-bin-hadoop2.<span class="number">6</span>/conf</span><br><span class="line">[root@EPRI-DCLOUD-ETL01 conf]<span class="comment"># ls</span></span><br><span class="line">docker.properties.template  fairscheduler.xml.template  hive-site.xml  log4j.properties  metrics.properties.template  slaves  spark-defaults.conf  spark-env.sh</span><br><span class="line">[root@EPRI-DCLOUD-ETL01 conf]<span class="comment"># vi spark-env.sh </span></span><br><span class="line"></span><br><span class="line">export SPARK_YARN_MODE=true</span><br><span class="line">export MASTER=yarn-client</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_55</span><br><span class="line">export SCALA_HOME=/usr/share/scala-<span class="number">2.11</span>.<span class="number">6</span></span><br><span class="line">export SPARK_MASTER_IP=EPRI-DCLOUD-HDP01</span><br><span class="line">export SPARK_CLASSPATH=<span class="variable">$SPARK_CLASSPATH:</span>/usr/share/spark-<span class="number">1.5</span>.<span class="number">2</span>-bin-hadoop2.<span class="number">6</span>/lib/*:/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/*:/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/etc/*:/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/lib/*</span><br><span class="line">export HADOOP_HOME=/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>export HADOOP_CONF_DIR=/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/etc/hadoop</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MariaDB安装及操作</title>
      <link href="/2018/04/28/MariaDB%E5%AE%89%E8%A3%85%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/04/28/MariaDB%E5%AE%89%E8%A3%85%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h3><pre><code>cupid-mariadb-5.5.52mariadb-5.5.31-winx64</code></pre><h3 id="安装步奏"><a href="#安装步奏" class="headerlink" title="安装步奏"></a>安装步奏</h3><p>解压缩软件<br>文件夹中，一般包含5个MySQL自带的配置文件，</p><pre><code>my-small.ini、my-medium.ini、my-large.ini、my-huge.ini和my-innodb-heavy-4G.ini，</code></pre><p>请你根据自己机器的内存大小，选择其一，并把它重新命名为my.ini用作基本配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[WinMySQLAdmin]</span><br><span class="line">Server=D:\YuanBo_Chi\mariadb-<span class="number">5.5</span>.31-winx64\bin\mysqld.exe</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">#password= [your_password]</span><br><span class="line">port= <span class="number">3306</span></span><br><span class="line">socket= /tmp/mysql.sock</span><br><span class="line"><span class="keyword">default</span>-character-set=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"># *** Application-specific options follow here ***</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># The MariaDB server</span><br><span class="line">#</span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># generic configuration options</span><br><span class="line">port= <span class="number">3306</span></span><br><span class="line">socket= /tmp/mysql.sock</span><br><span class="line">basedir=D:\YuanBo_Chi\mariadb-<span class="number">5.5</span>.31-winx64</span><br><span class="line">datadir=D:\YuanBo_Chi\mariadb-<span class="number">5.5</span>.31-winx64\data</span><br><span class="line"><span class="keyword">default</span>-character-set=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>在目录下运行 mysqld –install servicename则会创建名为servicename的Windows服务。我使用的是</p><pre><code>mysqld --install MariaDB </code></pre><p>等待成功后，<br>输入 </p><pre><code>net start MariaDB </code></pre><p>即可启动服务开始你的MariaDB之旅了。<br> 如果需要停止该服务，</p><p> 输入 </p><pre><code>net stop MariaDB </code></pre><p>即可停止服务<br>将创建完的服务的启动类型设为自动启动，并启动MariaDB。启动MariaDB时，会在data目录内创建数据文件和日志文件。</p><p>注：启动后的MariaDB 有一个默认的 root用户，其访问密码为空。修改密码的方法与MySQL类似，执行如下命令，即可修改root的访问密码。</p><pre><code>mysqladmin -u root password &quot;root&quot;</code></pre><p>顺便提一句，删除的时候也很简单，输入 </p><pre><code>mysqld.exe --remove MariaDB</code></pre><p>即可    </p><h3 id="图形化操作"><a href="#图形化操作" class="headerlink" title="图形化操作"></a>图形化操作</h3><p>下载Navicat Premium</p><p>链接MariaDB</p><p><img src="http://i4.buimg.com/1949/8e38fb3dd22b97d8.png" alt="Markdown"></p><p>ok</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Log4j</title>
      <link href="/2018/04/28/LOG4J/"/>
      <url>/2018/04/28/LOG4J/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">### 设置###</span><br><span class="line">log4j.rootLogger = info,stdout,D</span><br><span class="line"></span><br><span class="line">### 输出信息到控制抬 ###</span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern = [%-<span class="number">5</span>p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class="line"></span><br><span class="line">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><br><span class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.D.Append = <span class="keyword">true</span></span><br><span class="line">log4j.appender.D.Threshold = DEBUG</span><br><span class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"></span><br><span class="line">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br></pre></td></tr></table></figure><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>日志记录器(Logger)是日志处理的核心组件。log4j具有5种正常级别(Level)。日志记录器(Logger)的可用级别Level (不包括自定义级别 Level)， 以下内容就是摘自log4j API (<a href="http://jakarta.apache.org/log4j/docs/api/index.html)" target="_blank" rel="noopener">http://jakarta.apache.org/log4j/docs/api/index.html)</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Level WARN</span><br><span class="line">WARN level表明会出现潜在错误的情形。</span><br><span class="line"><span class="keyword">static</span> Level ERROR</span><br><span class="line">ERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。</span><br><span class="line"><span class="keyword">static</span> Level FATAL</span><br><span class="line">FATAL level指出每个严重的错误事件将会导致应用程序的退出。</span><br><span class="line">另外，还有两个可用的特别的日志记录级别: (以下描述来自log4j APIhttp:<span class="comment">//jakarta.apache.org/log4j/docs/api/index.html):</span></span><br><span class="line"><span class="keyword">static</span> Level ALL</span><br><span class="line">ALL Level是最低等级的，用于打开所有日志记录。</span><br><span class="line"><span class="keyword">static</span> Level OFF</span><br><span class="line">OFF Level是最高等级的，用于关闭所有日志记录。</span><br></pre></td></tr></table></figure><p>日志记录器（Logger）的行为是分等级的。如下表所示：<br>分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来，也是说大于等于的级别的日志才输出。</p><p>日志记录的级别有继承性，子类会记录父类的所有的日志级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">logger日志设置：</span><br><span class="line"><span class="number">1</span>、加包：log4j-<span class="number">1.2</span>.16.jar  一般还会加入 commons-logging-<span class="number">1.1</span>.1.jar</span><br><span class="line"><span class="number">2</span>、在CLASSPATH 下建立log4j.properties</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.stdout.Target=System.out  </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d %<span class="number">5</span>p %c&#123;<span class="number">1</span>&#125;:%L - %m%n  </span><br><span class="line"></span><br><span class="line">log4j.appender.file=org.apache.log4j.RollingFileAppender  </span><br><span class="line">log4j.appender.file.File=$&#123;catalina.home&#125;/logs/ddoMsg.log  </span><br><span class="line">#log4j.appender.file.File=D:/SmgpAppService/logs/smgpApp.log  </span><br><span class="line">log4j.appender.file.MaxFileSize=<span class="number">1024</span>KB  </span><br><span class="line">log4j.appender.file.MaxBackupIndex=<span class="number">100</span>  </span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.file.layout.ConversionPattern= %d&#123;yyyy-MM-dd HH:mm:ss&#125; %<span class="number">5</span>p %c %t: - %m%n  </span><br><span class="line"></span><br><span class="line">#INFO WARN ERROR DEBUG  </span><br><span class="line">log4j.rootLogger=WARN, file, stdout  </span><br><span class="line">#log4j.rootLogger=INFO,stdout  </span><br><span class="line">org.apache.commons.logging.Log=org.apache.commons.logging.impl.SimpleLog  </span><br><span class="line">#org.apache.commons.logging.simplelog.log.org.apache.commons.digester.Digester=debug  </span><br><span class="line">#org.apache.commons.logging.simplelog.log.org.apache.commons.digester.ObjectCreateRule=debug  </span><br><span class="line">#org.apache.commons.logging.simplelog.log.org.apache.commons.digester.Digester.sax=info  </span><br><span class="line"></span><br><span class="line">log4j.logger.com.jason.ddoMsg=debug</span><br></pre></td></tr></table></figure><p>在要输出的日志的类中<br>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.log4j.Logger logger = Logger.getLogger(类名.class);</span><br><span class="line">在类输位置：logger.info(XXX);</span><br></pre></td></tr></table></figure><p>logger 配置说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 log4j.rootLogger=INFO, stdout , R</span><br><span class="line"></span><br><span class="line">此句为将等级为INFO的日志信息输出到stdout和R这两个目的地，stdout和R的定义在下面的代码，可以任意起名。等级可分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，如果配置OFF则不打出任何信息，如果配置为INFO这样只显示INFO, WARN, ERROR的log信息，而DEBUG信息不会被显示，具体讲解可参照第三部分定义配置文件中的logger。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">此句为定义名为stdout的输出端是哪种类型，可以是</span><br><span class="line"></span><br><span class="line">org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.FileAppender（文件），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span><br><span class="line"></span><br><span class="line">org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">此句为定义名为stdout的输出端的layout是哪种类型，可以是</span><br><span class="line"></span><br><span class="line">org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、log4j.appender.stdout.layout.ConversionPattern= [QC] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line"></span><br><span class="line">如果使用pattern布局就要指定的打印信息的具体格式ConversionPattern，打印参数如下：</span><br><span class="line"></span><br><span class="line">%m 输出代码中指定的消息</span><br><span class="line"></span><br><span class="line">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span><br><span class="line"></span><br><span class="line">%r 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line"></span><br><span class="line">%c 输出所属的类目，通常就是所在类的全名</span><br><span class="line"></span><br><span class="line">%t 输出产生该日志事件的线程名</span><br><span class="line"></span><br><span class="line">%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”</span><br><span class="line"></span><br><span class="line">%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyyy MMM dd HH:mm:ss,SSS&#125;，输出类似：<span class="number">2002</span>年<span class="number">10</span>月<span class="number">18</span>日 <span class="number">22</span>：<span class="number">10</span>：<span class="number">28</span>，<span class="number">921</span></span><br><span class="line"></span><br><span class="line">%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line"></span><br><span class="line">[QC]是log信息的开头，可以为任意字符，一般为项目简称。</span><br><span class="line"></span><br><span class="line">输出的信息</span><br><span class="line"></span><br><span class="line">[TS] DEBUG [main] AbstractBeanFactory.getBean(<span class="number">189</span>) | Returning cached instance of singleton bean <span class="string">'MyAutoProxy'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、 log4j.appender.R=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line"></span><br><span class="line">此句与第<span class="number">3</span>行一样。定义名为R的输出端的类型为每天产生一个日志文件。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、log4j.appender.R.File=D:\\Tomcat <span class="number">5.5</span>\\logs\\qc.log</span><br><span class="line"></span><br><span class="line">此句为定义名为R的输出端的文件名为D:\\Tomcat <span class="number">5.5</span>\\logs\\qc.log可以自行修改。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、 log4j.appender.R.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">与第<span class="number">4</span>行相同。</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、 log4j.appender.R.layout.ConversionPattern=%d-[TS] %p %t %c - %m%n</span><br><span class="line"></span><br><span class="line">与第<span class="number">5</span>行相同。</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、 log4j.logger.com. neusoft =DEBUG</span><br><span class="line"></span><br><span class="line">指定com.neusoft包下的所有类的等级为DEBUG。</span><br><span class="line"></span><br><span class="line">可以把com.neusoft改为自己项目所用的包名。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、  log4j.logger.com.opensymphony.oscache=ERROR</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、 log4j.logger.NET.sf.navigator=ERROR</span><br><span class="line"></span><br><span class="line">这两句是把这两个包下出现的错误的等级设为ERROR，如果项目中没有配置EHCache，则不需要这两句。</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、log4j.logger.org.apache.commons=ERROR</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、 log4j.logger.org.apache.struts=WARN</span><br><span class="line"></span><br><span class="line">这两句是struts的包。</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>、  log4j.logger.org.displaytag=ERROR</span><br><span class="line"></span><br><span class="line">这句是displaytag的包。（QC问题列表页面所用）</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>、 log4j.logger.org.springframework=DEBUG</span><br><span class="line"></span><br><span class="line">此句为spring的包。</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>、 log4j.logger.org.hibernate.ps.PreparedStatementCache=WARN</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>、log4j.logger.org.hibernate=DEBUG</span><br><span class="line"></span><br><span class="line">此两句是hibernate的包。</span><br><span class="line"></span><br><span class="line">以上这些包的设置可根据项目的实际情况而自行定制。</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM性能优化， Part 5  ―― Java的伸缩性</title>
      <link href="/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%205%20%20%E2%80%95%E2%80%95%20Java%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7/"/>
      <url>/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%205%20%20%E2%80%95%E2%80%95%20Java%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>很多程序员在解决JVM性能问题的时候，花开了很多时间去调优应用程序级别的性能瓶颈，当你读完这本系列文章之后你会发现我可能更加系统地看待这类的问题。我说过JVM的自身技术限制了Java企业级应用的伸缩性。首先我们先列举一些主导因素。</p><ul><li><p>主流的硬件服务器提供了大量的内存</p></li><li><p>分布式系统有大量内存的需求，而且该需求在持续增长</p></li><li><p>一个普通Java应用程序所持有的对空间大概在1GB~4GB，这远远低于一个硬件服务器的内存管理能力以及一个分布式应用程序的内存需求量。这被称之为Java内存墙，如下图所示(图中表述Java应用服务器和常规Java应用的内存使用量的演变史)。</p></li></ul><p><img src="http://osapnihnq.bkt.clouddn.com/blog/180423/aH8h1m3BJ4.png?imageslim" alt="mark"></p><p>Java内存墙(1980~2010)   (图片来源：Azul Systems)</p><p>这给我们带来了如下JVM性能课题：</p><p>1) 如果分配给应用程序的内存太小，将导致内存不足。JVM 不能及时释放内存空间给应用程序，最终将引发内存不足，或者JVM完全关闭。所以你必须提供更多的内存给应用程序。</p><p>2) 如果给对响应时间敏感的应用增加内存，如果不重启你的系统或者优化你的应用，Java堆最终会碎片化。当碎片发生时，可能会导致应用中断100毫秒~100秒，这取决与你的Java应用，Java堆的大小以及其他的JVM调优参数。</p><p>关于停顿的讨论大部分都集中在平均停顿或者目标停顿，很少涉及到堆压缩时的最坏停顿时间，在生产环境中堆中每千兆字节的有效数据的都将会发生大约1秒的停顿。</p><p>2 ~ 4秒的停顿对大多数企业应用来说都是不能接受的，所以尽管实际的Java应用实例可能需要更多的内存空间，但实际只分配2~4GB的内存。在一些64位系统中带有很多关于伸缩性的JVM调优项，使得这些系统可以运行16GB乃至20GB的堆空间，并能满足典型响应时间的SLA。但是这些离现实较远，JVM目前的技术无法在进行堆压缩时避免停顿应用程序。Java应用开发人员苦于处理这两个为我们大多数人所抱怨的任务。</p><ul><li><p>架构/建模在大量的实例池之上，随之而来的是复杂的监控和管理操作。</p></li><li><p>反复的JVM和应用程序调优以避免“stop the world“引起的停顿。大多数程序员希望停顿不要发生在系统峰值负载期间。我称之为不可能的目标。</p></li></ul><p>现在让我们深入一点Java的可伸缩性问题。</p><p><strong>过度供给或过度实例化Java部署</strong></p><p>为了充分利用内存资源，普通的做法是将Java应用部署在多个应用服务器实例上而不是一个或者少数应用服务器实例上。当一台Server上运行16个应用服务器实例可以充分利用所有的内存资源，但如此无法解决的是多实例的监控以及管理所带来的成本，尤其是当你的应用部署在多个Server上。</p><p>另一个问题来了，峰值负载时的内存资源不是每天都需要的，这样就形成了巨大的浪费。有些情况下，一台物理机上可能只不是不超过3个“大应用服务器实例”，这样的部署更加不够经济也不够环保，尤其在非峰值负载期间。</p><p>让我们来比较一下这两种部署架构，下图中左边是多而小的应用服务器实例部署模式，右边是少而大的应用服务器实例部署模式。两种模式处理同样的负载，究竟哪一种部署架构更具经济性。</p><p><img src="http://osapnihnq.bkt.clouddn.com/blog/180423/c09mCc1LCK.png?imageslim" alt="mark"></p><p>大应用服务器部署场景 (图片来源：Azul Systems)</p><p>如我之前说过的，并发压缩使得大应用服务器部署模式变得可行，而且可以突破JVM可伸缩性的限制。目前只有Azul的Zing JVM可以提供并发压缩的技术，另外Zing是Server侧的JVM，我们很乐意看到越来越多的开发者在JVM层面去挑战Java可伸缩性的问题。</p><p>由于性能调优仍然是我们解决Java可伸缩性问题的主要手段，我们先来看有哪些主要的调优参数以及通过它们能达到什么样的效果。</p><p><strong>调优参数：一些事例</strong></p><p>最著名的调优参数莫过于”-Xmx”了，通过该参数可以指定Java的堆空间大小，实际上可能不同的JVM执行结果不太一样。</p><p>有的JVM包含了内部结构(如编译器线程，垃圾回收器结构，代码缓存等等)所需要的内存在“-Xmx”的设定中，而有的则不包含。因此用户Java进程的大小不一定跟“-Xmx”的设定相吻合。</p><p>如果你的应用程序分配对象的速率，对象的生命周期，或者对象的大小超过了JVM内存相关配置，一旦达到最大可使用内存的阈值将会发生内存溢出，用户进程则会停止。</p><p>当你的应用程序纠结于内存的可用性时，最有效的方法就是通过”-Xmx”指定更大的内存去重启当前应用进程。为了避免频繁的重启，大多数企业生产环境都倾向于指定峰值负载时所需要的内存，造成过度配置优化。</p><p><strong>提示：</strong>生产环境负载的调整</p><p>Java开发人员易犯的常见错误是在实验下的做的堆内存设置，在移植到生产环境是忘记重新调整。生产环境和实验室环境是不一样的，谨记根据生产环境的负载重新调整堆内存设置。</p><p><strong>分代垃圾回收器调优</strong></p><p>还有一些其他的优化选项”-Xns”和”-XX: NewSize”，用来调整年轻代的大小，用来指定堆中专门负责新对象分配的空间大小。</p><p>大多数开发者都试图基于实验室环境调整年轻代的大小，这意味着在生产负载下存在失败的风险。一般新生代的大小设置为堆大小的三分之一至二分之一左右，但这不是一个准则，毕竟实际还要视应用程序逻辑而定。因此最好先调查清楚年轻代到年老代的蜕变率以及年老代对象的大小，在此基础上(确保年老代的大小，年老代过小会频繁促发GC导致内存溢出错误)尽可能地调大年轻代的空间。</p><p>还有一个与年轻代相关的调优项”-XX:SurvivorRatio”，该选项用来指定年轻代中对象的生命周期，超过指定时长相关对象将被移至年老代。为了”正确”地设定该值，你需要知道年轻代空间回收的频率，能够估算到新对象在应用程序进程中被引用的时长，同时也取决于分配率。</p><p><strong>并发垃圾回收调优</strong></p><p>针对对停顿敏感的应用，建议使用并发垃圾回收，虽然并行的办法能够带来非常好的吞吐量基准测试分数，但是并行GC不利于缩短响应时间。并发 GC 是目前唯一有效的实现一致性和最少“stop the world”中断的方法。不同的JVM提供不同的并发GC的设定，Oracle JVM(hotspot)提供”-XX:+UseConcMarkSweepGC”,今后G1将成为Oracle JVM默认的并发垃圾回收器。</p><p><strong>性能调优并不是真正的解决办法</strong></p><p>或许你已经注意到上文中在讨论如何“正确“地设定调优此参数时，我刻意在”正确“二字上加了双引号。那是因为就我个人经验而言一旦涉及到性能参数调优，就没有严格意义上的正确设定。每一个设定值都是针对特定的场景。考虑到应用场景会发生变化，JVM 性能调整充其量是一个权宜之计。</p><p>以堆的设置为例：如果2GB的堆可以应对20万并发用户，但是可能不能应付40万的并发用户。</p><p>我们再以”-XX:SurvivorRatio”为例：当设定符合一个负载持续增长最高至每毫秒10000个交易的场景，当压力到达每毫秒50000个交易时又会发生什么呢？</p><p>大多数企业级应用负载都是动态的，Java语言的动态内存管理以及动态编译等技术使得Java更加适合企业级应用。我们来看看一下两个配置清单。</p><p>清单1. 应用程序(1)的启动选项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;java -Xmx12g -XX:MaxPermSize=<span class="number">64</span>M -XX:PermSize=<span class="number">32</span>M -XX:MaxNewSize=<span class="number">2</span>g </span><br><span class="line">-XX:NewSize=<span class="number">1</span>g -XX:SurvivorRatio=<span class="number">16</span> -XX:+UseParNewGC </span><br><span class="line">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=<span class="number">0</span> </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=<span class="number">60</span> -XX:+CMSParallelRemarkEnabled </span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly -XX:ParallelGCThreads=<span class="number">12</span> </span><br><span class="line">-XX:LargePageSizeInBytes=<span class="number">256</span>m …</span><br></pre></td></tr></table></figure><p>清单2. 应用程序(2)的启动选项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;java --Xms8g --Xmx8g --Xmn2g -XX:PermSize=<span class="number">64</span>M -XX:MaxPermSize=<span class="number">256</span>M </span><br><span class="line">-XX:-OmitStackTraceInFastThrow -XX:SurvivorRatio=<span class="number">2</span> -XX:-UseAdaptiveSizePolicy -XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:+CMSConcurrentMTEnabled -XX:+CMSParallelRemarkEnabled -XX:+CMSParallelSurvivorRemarkEnabled </span><br><span class="line">-XX:CMSMaxAbortablePrecleanTime=<span class="number">10000</span> -XX:+UseCMSInitiatingOccupancyOnly </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=<span class="number">63</span> -XX:+UseParNewGC --Xnoclassgc …</span><br></pre></td></tr></table></figure><p>两者的配置区别很大，因为他们是两个不同应用程序。感觉根据各自的应用特设都做了”正确“的配置与调优。在实验室环境下都运行良好，但在生产环境中最终会表现出疲态。清单1由于没有考虑到动态负载，到了生产环境即表现不良。清单2没有考虑到应用程序在生产环境中的特性变化。这两种情况应该归咎于开发团队，但是该归咎于何处呢？</p><p><strong>变通办法可行吗？</strong></p><p>有些企业通过精确测量交易对象的大小定义极致的对象回收空间并”精简“其架构来适配该空间。这也许是办法来削减碎片以应对一整天的交易(在不做堆压缩的情况下)。还有一个办法就是通过程序设计确保对象被引用的时间在一个比较短的时间内从而阻止其在SurvivorRatio时间之后不被迁往年老代而直接被回收，避免内存压缩的场景。这两种办法都可以，但是对应用开发人员和设计人员有一定的挑战。</p><p><strong>谁保障应用程序的性能？</strong></p><p>一个门户应用可能会在其活动负载峰值点出现故障；一个交易应用可能会在每次市场下跌和上升时无法正常运行；电子商务网站可能会无法应对节假日购物高峰期。这些都是真实世界的案例基本都是JVM性能参数调优导致的。当产生了经济损失，开发团队就会受到责备。也许某些场合下开发团队应该要受到责备，但是JVM的提供商又应该负起什么样儿的责任呢？</p><p>首先JVM提供商应该要提供调优参数的优先顺序，至少这在短期内还是很有意义的。有一些新的调优选项是针对特定的、 新兴的企业应用程序场景。更多的调优选项是为了减轻JVM支持团队的工作负荷而将性能优化转嫁到应用开发者身上。但我个人认为这或将导致更加漫长的支持负荷，一些针对最糟糕场景的调优选项也将被延期，当然不是无限延期。</p><p>毋庸置疑JVM的开发团队也在努力地进行着他们的工作，同时也只有应用实施者才会更加清楚他们应用的特定需求。但是应用的实施者或开发者是无法预测期动态的负载需求。在过去，JVM提供商也会去分析关于Java的性能与可扩展性问题，哪些是他们能够解决的。不是提供调优参数，而是直接去优化或创新垃圾回收的算法。更有趣是我们可以想象一下如果OpenJDK的社区聚集在一起重新考虑Java垃圾回收器将会发生什么！</p><p><strong>JVM**</strong>性能的基准测试**</p><p>调优参数有时被JVM提供商作为其竞争的工具，因为不同的调优可以改善他们的JVM在可预见的环境中的性能表现，本系列的最后一片文章中将调查这些基准测试来衡量JVM的性能。</p><p><strong>JVM**</strong>开发者的挑战**</p><p>真正的企业级可伸缩性需求是要求JVM能够适应动态灵活的应用负载。这是在特定吞吐量和响应时间内保证持续稳定性能的关键。这是JVM开发者才能完成历史使命，因此是时候号召我们Java开发者社区来迎接真正的Java可伸缩性的挑战。</p><ul><li>持续调优</li></ul><p>对于给定的应用，在一开始需要告知其需要多大的内存，之后的工作都应该有JVM来负责 ，JVM需要适配动态的应用负载和运行场景。</p><ul><li>JVM实例数 vs. 实例的可扩展性</li></ul><p>现在的服务器都支持很大的内存，那么为什么JVM实例不能有效地利用它呢？将应用拆分部署许多小的应用服务器实例上，这从经济和环保角度都是一种浪费。现代的JVM需要跟上硬件和应用的发展潮流。</p><ul><li>真实世界的性能和可伸缩性</li></ul><p>企业不需要为其应用的性能需求去做极致的性能调优。JVM提供商和OpenJDK社区需要去解决Java可伸缩性的核心问题以及消除“stop the world“的操作。</p><p><strong>结论</strong></p><p>如果JVM做了这样的工作，并且提供了并发压缩的垃圾回收算法，JVM也不再成为Java可伸缩性的限制因素，Java应用开发者不需要花费痛苦的时间理解怎样配置JVM去获得最佳性能，从而将会有更多的有趣的Java应用层面的创新，而不是无休止的JVM调优。我要挑战JVM开发人员以及提供商所需要做的事情来相应甲骨文所提倡的“Make the Java Future“的活动。</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：Eva Andreasson,译者：吴杰 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM性能优化， Part 4  ―― C4 垃圾回收</title>
      <link href="/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%204%20%E2%80%95%E2%80%95%20C4%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%204%20%E2%80%95%E2%80%95%20C4%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<p>本文是JVM性能优化 系列-第4篇。前3篇文章请参考文章结尾处的JVM优化系列文章。作为Eva Andreasson的JVM性能优化系列的第4篇，本文将对C4垃圾回收器进行介绍。使用C4垃圾回收器可以有效提升对低延迟有要求的企业级Java应用程序的伸缩性。</p><p>到目前为止，本系列的文章将stop-the-world式的垃圾回收视为影响Java应用程序伸缩性的一大障碍，而伸缩性又是现代企业级Java应用程序开发的基础要求，因此这一问题亟待改善。幸运的是，针对此问题，JVM中已经出现了一些新特性，所使用的方式或是对stop-the-world式的垃圾回收做微调，或是消除冗长的暂停（这样更好些）。在一些多核系统中，内存不再是稀缺资源，因此，JVM的一些新特性就充分利用多核系统的潜在优势来增强Java应用程序的伸缩性。</p><p>在本文中，我将着重介绍C4算法，该算法是Azul System公司中无暂停垃圾回收算法的新成果，目前只在Zing JVM上得到实现。此外，本文还将对Oracle公司的G1垃圾回收算法和IBM公司的Balanced Garbage Collection Policy算法做简单介绍。希望通过对这些垃圾回收算法的学习可以扩展你对Java内存管理模型和Java应用程序伸缩性的理解，并激发你对这方面内容的兴趣以便更深入的学习相关知识。至少，你可以学习到在选择JVM时有哪些需要关注的方面，以及在不同应用程序场景下要注意的事项。</p><p><strong>C4算法中的并发性</strong></p><p>Azul System公司的C4（Concurrent Continuously Compacting Collector，译者注，Azul官网给出的名字是Continuously Concurrent Compacting Collector）算法使用独一无二而又非常有趣的方法来实现低延迟的分代式垃圾回收。相比于大多数分代式垃圾回收器，C4的不同之处在于它认为垃圾回收并不是什么坏事（即应用程序产生垃圾很正常），而压缩是不可避免的。在设计之初，C4就是要牺牲各种动态内存管理的需求，以满足需要长时间运行的服务器端应用程序的需求。</p><p>C4算法将释放内存的过程从应用程序行为和内存分配速率中分离出来，并加以区分。这样就实现了并发运行，即应用程序可以持续运行，而不必等待垃圾回收的完成。其中的并发性是关键所在，正是由于并发性的存在才可以使暂停时间不受垃圾回收周期内堆上活动数据数量和需要跟踪与更新的引用数量的影响，将暂停时间保持在较低的水平。正如我在本系列<a href="https://github.com/chiyuanbo/cyb-mds/blob/master/java/jvm/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%203%20%20%E2%80%95%E2%80%95%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" target="_blank" rel="noopener">第3篇</a>中介绍的一样，大多数垃圾回收器在工作周期内都包含了stop-the-world式的压缩过程，这就是说应用程序的暂停时间会随活动数据总量和堆中对象间引用的复杂度的上升而增加。使用C4算法的垃圾回收器可以并发的执行压缩操作，即压缩与应用程序线程同时工作，从而解决了影响JVM伸缩性的最大难题。</p><p>实际上，为了实现并发性，C4算法改变了现代Java企业级架构和部署模型的基本假设。想象一下拥有数百GB内存的JVM会是什么样的：</p><ul><li>部署Java应用程序时，对伸缩性的要求无需要多个JVM配合，在单一JVM实例中即可完成。这时的部署是什么样呢？</li><li>有哪些以往因GC限制而无法在内存存储的对象？</li><li>那些分布式集群（如缓存服务器、区域服务器，或其他类型的服务器节点）会有什么变化？当可以增加JVM内存而不会对应用程序响应时间造成负面影响时，传统的节点数量、节点死亡和缓存丢失的计算会有什么变化呢？</li></ul><p><strong>C4算法的3的阶段</strong></p><p>C4算法的一个基本假设是“垃圾回收不是坏事”和“压缩不可避免”。C4算法的设计目标是实现垃圾回收的并发与协作，剔除stop-the-world式的垃圾回收。C4垃圾回收算法包含一下3个阶段：</p><ol><li><em>标记（Marking）</em> — 找到活动对象</li><li><em>重定位（Relocation）</em> — 将存活对象移动到一起，以便可以释放较大的连续空间，这个阶段也可称为“压缩（compaction）”</li><li><em>重映射（Remapping）</em> — 更新被移动的对象的引用。</li></ol><p>下面的内容将对每个阶段做详细介绍。</p><p><strong>C4算法中的标记阶段</strong></p><p>在C4算法中，<em>标记阶段（marking phase）</em>使用了<em>并发标记（concurrent marking）</em>和引用跟踪<em>（reference-tracing）</em>的方法来标记活动对象，这方面内容已经在本系列的<a href="https://github.com/chiyuanbo/cyb-mds/blob/master/java/jvm/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%203%20%20%E2%80%95%E2%80%95%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" title="Collection" target="_blank" rel="noopener">第3篇</a>中介绍过。</p><p>在标记阶段中，GC线程会从线程栈和寄存器中的活动对象开始，遍历所有的引用，标记找到的对象，这些GC线程会遍历堆上所有的可达（reachable）对象。在这个阶段，C4算法与其他并发标记器的工作方式非常相似。</p><p>C4算法的标记器与其他并发标记器的区别也是始于并发标记阶段的。在并发标记阶段中，如果应用程序线程修改未标记的对象，那么该对象会被放到一个队列中，以备遍历。这就保证了该对象最终会被标记，也因为如此，C4垃圾回收器或另一个应用程序线程不会重复遍历该对象。这样就节省了标记时间，消除了递归重标记（recursive remark）的风险。（注意，长时间的递归重标记有可能会使应用程序因无法获得足够的内存而抛出OOM错误，这也是大部分垃圾回收场景中的普遍问题。）</p><p><a href="http://www.importnew.com/?attachment_id=2411" target="_blank" rel="noopener"><img src="http://www.importnew.com/wp-content/uploads/2013/01/jvmseries4-fig1-300x164.png" alt="" title="jvmseries4-fig1"></a></p><p>Figure 1. Application threads traverse the heap just once during marking</p><p>如果C4算法的实现是基于脏卡表（dirty-card tables）或其他对已经遍历过的堆区域的读写操作进行记录的方法，那垃圾回收线程就需要重新访问这些区域做重标记。在极端条件下，垃圾回收线程会陷入到永无止境的重标记中 —— 至少这个过程可能会长到使应用程序因无法分配到新的内存而抛出OOM错误。但C4算法是基于<em>LVB（load value barrier）</em>实现的，LVB具有自愈能力，可以使应用程序线程迅速查明某个引用是否已经被标记过了。如果这个引用没有被标记过，那么应用程序会将其添加到GC队列中。一旦该引用被放入到队列中，它就不会再被重标记了。应用程序线程可以继续做它自己的事。</p><p><em>脏对象（dirty object）和卡表（card table）</em><br>由于某些原因（例如在一个并发垃圾回收周期中，对象被修改了），垃圾回收器需要重新访问某些对象，那么这些对象<em>脏对象（dirty object）</em>。这这些脏对象，或堆中脏区域的引用，通过会记录在一个专门的数据结构中，这就是卡表。</p><p>在C4算法中，并没有重标记（re-marking）这个阶段，在第一次便利整个堆时就会将所有可达对象做标记。因为运行时不需要做重标记，也就不会陷入无限循环的重标记陷阱中，由此而降低了应用程序因无法分配到内存而抛出OOM错误的风险。</p><p><strong>C4算法中的重定位 ——　应用程序线程与GC的协作</strong></p><p>C4算法中，<em>重定位阶段（reloacation phase）</em>是由GC线程和应用程序线程以协作的方式，并发完成的。这是因为GC线程和应用程序线程会同时工作，而且无论哪个线程先访问将被移动的对象，都会以协作的方式帮助完成该对象的移动任务。因此，应用程序线程可以继续执行自己的任务，而不必等待整个垃圾回收周期的完成。</p><p>正如Figure 2所示，碎片内存页中的活动对象会被重定位。在这个例子中，应用程序线程先访问了要被移动的对象，那么应用程序线程也会帮助完成移动该对象的工作的初始部分，这样，它就可以很快的继续做自己的任务。虚拟地址（指相关引用）可以指向新的正确位置，内存也可以快速回收。</p><p><a href="http://www.importnew.com/2410.html/jvmseries4-fig2" target="_blank" rel="noopener"><img src="http://www.importnew.com/wp-content/uploads/2013/01/jvmseries4-fig2-300x169.png" alt="" title="jvmseries4-fig2"></a></p><p>Figure 2. A page selected for relocation and the empty new page that it will be moved to</p><p>如果是GC线程先访问到了将被移动的对象，那事情就简单多了，GC线程会执行移动操作的。如果在重映射阶段（re-mapping phase，后续会提到）也访问这个对象，那么它必须检查该对象是否是要被移动的。如果是，那么应用程序线程会重新定位这个对象的位置，以便可以继续完成自己任务。（对大对象的移动是通过将该对象打碎再移动完成的。如果你对这部分内容感兴趣的话，推荐你阅读一下相关资源中的这篇白皮书“C4: The Continuously Concurrent Compacting Collector”）</p><p>当所有的活动对象都从某个内存也中移出后，剩下的就都是垃圾数据了，这个内存页也就可以被整体回收了。正如Figure 2中所示。</p><p><em>关于清理</em><br>在C4算法中并没有清理阶段（sweep phase），因此也就不需要这个在大多数垃圾回收算法中比较常用的操作。在指向被移动的对象的引用都更新为指向新的位置之前，from页中的虚拟地址空间必须被完整保留。所以C4算法的实现保证了，在所有指向这个页的引用处于稳定状态前，所有的虚拟地址空间都会被锁定。然后，算法会立即回收物理内存页。</p><p>很明显，无需执行stop-the-world式的移动对象是有很大好处的。由于在重定位阶段，所有活动对象都是并发移动的，因此它们可以被更有效率的放入到相邻的地址中，并且可以充分的压缩。通过并发执行重定位操作，堆被压缩为连续空间，也无需挂起所有的应用程序线程。这种方式消除了Java应用程序访问内存的传统限制（更多关于Java应用程序内存模型的内容参见ImportNew编译整理的第一篇《<a href="http://www.importnew.com/1774.html" target="_blank" rel="noopener">JVM性能优化， Part 1 ―― JVM简介</a>》）。</p><p>经过上述的过程后，如何更新引用呢？如何实现一个非stop-the-world式的操作呢？</p><p><strong>C4算法中的重映射</strong></p><p>在重定位阶段，某些指向被移动的对象的引用会自动更新。但是，在重定位阶段，那些指向了被移动的对象的引用并没有更新，仍然指向原处，所以它们需要在后续完成更新操作。C4算法中的<em>重映射阶段（re-mapping phase）</em>负责完成对那些活动对象已经移出，但仍指向那些的引用进行更新。当然，重映射也是一个协作式的并发操作。</p><p>Figure 3中，在重定位阶段，活动对象已经被移动到了一个新的内存页中。在重定位之后，GC线程立即开始更新那些仍然指向之前的虚拟地址空间的引用，将它们指向那些被移动的对象的新地址。垃圾回收器会一直执行此项任务，直到所有的引用都被更新，这样原先虚拟内存空间就可以被整体回收了。</p><p><a href="http://www.importnew.com/2410.html/jvmseries4-fig3" target="_blank" rel="noopener"><img src="http://www.importnew.com/wp-content/uploads/2013/01/jvmseries4-fig3-300x188.png" alt="" title="jvmseries4-fig3"></a></p><p>Figure 3. Whatever thread finds an invalid address enables an update to the correct new address</p><p>但如果在GC完成对所有引用的更新之前，应用程序线程想要访问这些引用的话，会出现什么情况呢？在C4算法中，应用程序线程可以很方便的帮助完成对引用进行更新的工作。如果在重映射阶段，应用程序线程访问了处于非稳定状态的引用，它会找到该引用的正确指向。如果应用程序线程找到了正确的引用，它会更新该引用的指向。当完成更新后，应用程序线程会继续自己的工作。</p><p>协作式的重映射保证了引用只会被更新一次，该引用下的子引用也都可以指向正确的新地址。此外，在大多数其他GC实现中，引用指向的地址不会被存储在该对象被移动之前的位置；相反，这些地址被存储在一个堆外结构（off-heap structure）中。这样，无需在对所有引用的更新完成之前，再花费精力保持整个内存页完好无损，这个内存页可以被整体回收。</p><p><strong>C4算法真的是无暂停的么？</strong></p><p>在C4算法的重映射阶段，正在跟踪引用的线程仅会被中断一次，而这次中断仅仅会持续到对该引用的检索和更新完成，在这次中断后，线程会继续运行。相比于其他并发算法来说，这种实现会带来巨大的性能提升，因为其他的并发立即回收算法需要等到每个线程都运行到一个安全点（safe point），然后同时挂起所有线程，再开始对所有的引用进行更新，完成后再恢复所有线程的运行。</p><p>对于并发压缩垃圾回收器来说，由于垃圾回收所引起的暂停从来都不是问题。在C4算法的重定位阶段中，也不会有再出现更糟的碎片化场景了。实现了C4算法的垃圾回收器也不会出现背靠背（back-to-back）式的垃圾回收周期，或者是因垃圾回收而使应用程序暂停数秒甚至数分钟。如果你曾经体验过这种stop-the-world式的垃圾回收，那么很有可能是你给应用程序设置的内存太小了。你可以试用一下实现了C4算法的垃圾回收器，并为其分配足够多的内存，而完全不必担心暂停时间过长的问题。</p><p><strong>评估C4算法和其他可选方案</strong></p><p>像往常一样，你需要针对应用程序的需求选择一款JVM和垃圾回收器。C4算法在设计之初就是无论堆中活动数据有多少，只要应用程序还有足够的内存可用，暂停时间都始终保持在较低的水平。正因如此，对于那些有大量内存可用，而对响应时间比较敏感的应用程来说，选择实现了C4算法的垃圾回收器正是不二之选。</p><p>而对于那些要求快速启动，内存有限的客户端应用程序来说，C4就不是那么适用。而对于那些对吞吐量有较高要求的应用程序来说，C4也并不适用。真正能够发挥C4威力的是那些为了提升应用程序工作负载而在每台服务器上部署了4到16个JVM实例的场景。此外，如果你经常要对垃圾回收器做调优的话，那么不妨考虑一下使用C4算法。综上所述，当响应时间比吞吐量占有更高的优先级时，C4是个不错的选择。而对那些不能接受长时间暂停的应用程序来说，C4是个理想的选择。</p><p>如果你正考虑在生产环境中使用C4，那么你可能还需要重新考虑一下如何部署应用程序。例如，不必为每个服务器配置16个具有2GB堆的JVM实例，而是使用一个64GB的JVM实例（或者增加一个作为热备份）。C4需要尽可能大的内存来保证始终有一个空闲内存页来为新创建的对象分配内存。（记住，内存不再是昂贵的资源了！）</p><p>如果你没有64GB，128GB，或1TB（或更多）内存可用，那么分布式的多JVM部署可能是一个更好的选择。在这种场景中，你可以考虑使用Oracle HotSpot JVM的G1垃圾回收器，或者IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）。下面将对这两种垃圾回收器做简单介绍。</p><p><strong>Gargabe-First （G1） 垃圾回收器</strong></p><p>G1垃圾回收器是新近才出现的垃圾回收器，是Oracle HotSpot JVM的一部分，在最近的JDK1.6版本中首次出现（译者注，该文章写于2012-07-11）。在启动Oracle JDK时附加命令行选项<em>-XX:+UseG1GC</em>，可以启动G1垃圾回收器。</p><p>与C4类似，这款标记-清理（mark-and-sweep）垃圾回收器也可作为对低延迟有要求的应用程序的备选方案。G1算法将堆分为固定大小区域，垃圾回收会作用于其中的某些区域。在应用程序线程运行的同时，启用后台线程，并发的完成标记工作。这点与其他并发标记算法相似。</p><p>G1增量方法可以使暂停时间更短，但更频繁，而这对一些力求避免长时间暂停的应用程序来说已经足够了。另一方面，正如在本系列的[Part 3][4]中介绍的，使用G1垃圾回收器需要针对应用程序的实际需求做长时间的调优，而其GC中断又是stop-the-world式的。所以对那些对低延迟有很高要求的应用程序来说，G1并不是一个好的选择。进一步说，从暂停时间总长来看，G1长于CMS（Oracle JVM中广为人知的并发垃圾回收器）。</p><p>G1使用拷贝算法（在Part 3中介绍过）完成部分垃圾回收任务。这样，每次垃圾回收器后，都会产生完全可用的空闲空间。G1垃圾回收器定义了一些区域的集合作为年轻代，剩下的作为老年代。</p><p>G1已经吸引了足够多的注意，引起了不小的轰动，但是它真正的挑战在于如何应对现实世界的需求。正确的调优就是其中一个挑战 —— 回忆一下，对于动态应用程序负载来说，没有永远“正确的调优”。一个问题是如何处理与分区大小相近的大对象，因为剩余的空间会成为碎片而无法使用。还有一个性能问题始终困扰着低延迟垃圾回收器，那就是垃圾回收器必须管理额外的数据结构。就我来说，使用G1的关键问题在于如何解决stop-the-world式垃圾回收器引起的暂停。Stop-the-world式的垃圾回收引起的暂停使任何垃圾回收器的能力都受制于堆大小和活动数据数量的增长，对企业级Java应用程序的伸缩性来说是一大困扰。</p><p><strong>IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）</strong></p><p>IBM JVM的平衡垃圾回收（Balanced Garbage Collection BGC）策略通过在启动IBM JDK时指定命令行选项<em>-Xgcpolicy:balanced</em>来启用。乍一看，BGC很像G1，它也是将Java堆划分成相同大小的空间，称为区间（region），执行垃圾回收时会对每个区间单独回收。为了达到最佳性能，在选择要执行垃圾回收的区间时使用了一些启发性算法。BGC中关于代的划分也与G1相似。</p><p>IBM的平衡垃圾回收策略仅在64位平台得到实现，是一种NUMA架构（Non-Uniform Memory Architecture），设计之初是为了用于具有4GB以上堆的应用程序。由于拷贝算法或压缩算法的需要，BGC的部分垃圾回收工作是stop-the-world式的，并非完全并发完成。所以，归根结底，BGC也会遇到与G1和其他没有实现并发压缩选法的垃圾回收器相似的问题。</p><p><strong>结论：回顾</strong></p><p>C4是基于引用跟踪的、分代式的、并发的、协作式垃圾回收算法，目前只在Azul System公司的Zing JVM得到实现。C4算法的真正价值在于：</p><ul><li>消除了重标记可能引起的重标记无限循环，也就消除了在标记阶段出现OOM错误的风险。</li><li>压缩，以自动、且不断重定位的方式消除了固有限制：堆中活动数据越多，压缩所引起的暂停越长。</li><li>垃圾回收不再是stop-the-world式的，大大降低垃圾回收对应用程序响应时间造成的影响。</li><li>没有了清理阶段，降低了在完成GC之前就因为空闲内存不足而出现OOM错误的风险。</li><li>内存可以以页为单位立即回收，使那些需要使用较多内存的Java应用程序有足够的内存可用。</li></ul><p>并发压缩是C4独一无二的优势。使应用程序线程GC线程协作运行，保证了应用程序不会因GC而被阻塞。C4将内存分配和提供足够连续空闲内存的能力完全区分开。C4使你可以为JVM实例分配尽可能大的内存，而无需为应用程序暂停而烦恼。使用得当的话，这将是JVM技术的一项革新，它可以借助于当今的多核、TB级内存的硬件优势，大大提升低延迟Java应用程序的运行速度。</p><p>如果你不介意一遍又一遍的调优，以及频繁的重启的话，如果你的应用程序适用于水平部署模型的话（即部署几百个小堆JVM实例而不是几个大堆JVM实例），G1也是个不错的选择。</p><p>对于动态低延迟启发性自适应（dynamic low-latency heuristic adaption）算法而言，BGC是一项革新，JVM研究者对此算法已经研究了几十年。该算法可以应用于较大的堆。而动态自调优算法（ dynamic self-tuning algorithm）的缺陷是，它无法跟上突然出现的负载高峰。那时，你将不得不面对最糟糕的场景，并根据实际情况再分配相关资源。</p><p>最后，为你的应用程序选择最适合的JVM和垃圾回收器时，最重要的考虑因素是应用程序中吞吐量和暂停时间的优先级次序。你想把时间和金钱花在哪？从纯粹的技术角度说，基于我十年来对垃圾回收的经验，我一直在寻找更多关于并发压缩的革新性技术，或其他可以以较小代价完成移动对象或重定位的方法。我想影响企业级Java应用程序伸缩性的关键就在于并发性。</p><p><strong>JVM 性能优化系列</strong></p><p>第一篇 《<a href="http://www.importnew.com/1774.html" target="_blank" rel="noopener">JVM性能优化， Part 1 ―― JVM简介</a> 》</p><p>第二篇《<a href="http://www.importnew.com/2009.html" target="_blank" rel="noopener">JVM性能优化， Part 2 ―― 编译器</a>》</p><p><strong>第三篇<a href="http://www.importnew.com/2233.html" target="_blank" rel="noopener">《JVM性能优化， Part 3 —— 垃圾回收》</a></strong></p>]]></content>
      
      
        <tags>
            
            <tag> 作者：Eva Andreasson,译者：曹旭东 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM性能优化， Part 3  ―― 垃圾回收</title>
      <link href="/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%203%20%20%E2%80%95%E2%80%95%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%203%20%20%E2%80%95%E2%80%95%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      <content type="html"><![CDATA[<p>Java平台的垃圾回收机制大大提高的开发人员的生产力，但实现糟糕的垃圾回收器却会大大消耗应用程序的资源。本文作为JVM性能优化系列的第3篇，Eva Andeasson将为Java初学者介绍Java平台的内存模型和GC机制。她将解释为什么碎片化（不是GC）是Java应用程序出现性能问题的主要原因，以及为什么当前主要通过分代垃圾回收和压缩，而不是其他最具创意的方法，来解决Java应用程序中碎片化的问题。</p><p>垃圾回收（GC）是旨在释放不可达Java对象所占用的内存的过程，是Java virtual machine（JVM）中动态内存管理系统的核心组成部分。在一个典型的垃圾回收周期中，所有仍被引用的对象，即可达对象，会被保留。没有被引用的Java对象所占用的内存会被释放并回收，以便分配给新创建的对象。</p><p>为了更好的理解垃圾回收与各种不同的GC算法，你首先需要了解一些关于Java平台内存模型的内容。</p><p><strong>垃圾回收与Java平台内存模型</strong></p><p>当你在启动Java应用程序时指定了启动参数<em>-Xmx</em>（例如，java -Xmx2g MyApp），则相应大小的内存会被分配给Java进程。这块内存即所谓的<em>Java堆</em>（或简称为<em>堆</em>）。这块专用的内存地址空间用于存储Java应用程序（有时是JVM）所创建的对象。随着Java应用程序的运行，会不断的创建新对象并为之分配内存，Java堆（即地址空间）会逐渐被填满。</p><p>最后，Java堆会被填满，这就是说想要申请内存的线程无法获得一块足够大的连续空闲空间来存放新创建的对象。此时，JVM判断需要启动垃圾回收器来回收内存了。当Java程序调用System.gc()方法时，也有可能会触发垃圾回收器以执行垃圾回收的工作。使用System.gc()方法并不能保证垃圾回收工作肯定会被执行。在执行垃圾回收前，垃圾回收机制首先会检查当前是否是一个“恰当的时机”，而“恰当的时机”指所有的应用程序活动线程都处于安全点（safe point），以便启动垃圾回收。简单举例，为对象分配内存时，或正在优化CPU指令（参见本系列的<a href="http://www.javaworld.com/javaworld/jw-09-2012/120905-jvm-performance-optimization-compilers.html" target="_blank" rel="noopener">前一篇文章</a>）时，就不是“恰当的时机”，因为你可能会丢失上下文信息，从而得到混乱的结果。</p><p>垃圾回收不应该回收当前有活动引用指向的对象所占用的内存；因为这样做将违反<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/index.html" target="_blank" rel="noopener">JVM规范</a>。在JVM规范中，并没有强制要求垃圾回收器立即回收已死对象（dead object）。已死对象最终会在后续的垃圾回收周期中被释放掉。目前，已经有多种垃圾回收的实现，它们都包含两个沟通的假设。对垃圾回收来说，真正的挑战在于标识出所有活动对象（即仍有引用指向的对象），回收所有不可达对象所占用的内存，并尽可能不对正在运行的应用程序产生影响。因此，垃圾回收器运行的两个目标：</p><ol><li>快速释放不可达对象所占用的内存，防止应用程序出现OOM错误。</li><li>回收内存时，对应用程序的性能（指延迟和吞吐量）的影响要紧性能小。</li></ol><p><strong>两类垃圾回收</strong></p><p>在本系列的<a href="https://github.com/chiyuanbo/cyb-mds/blob/master/java/jvm/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%201%20%E2%80%95%E2%80%95%20JVM%E7%AE%80%E4%BB%8B.md" target="_blank" rel="noopener">第一篇文章</a>中，我提到了2种主要的垃圾回收方式，引用计数（reference counting）和引用追踪（tracing collector。译者注，在第一篇中，给出的名字是“reference tracing”，这里仍沿用之前的名字）。这里，我将深入这两种垃圾回收方式，并介绍用于生产环境的实现了引用追踪的垃圾回收方式的相关算法。</p><p><strong>引用计数垃圾回收器</strong></p><p>引用计数垃圾回收器会对指向每个Java对象的引用数进行跟踪。一旦发现指向某个对象的引用数为0，则立即回收该对象所占用的内存。引用计数垃圾回收的主要优点就在于可以立即访问被回收的内存。垃圾回收器维护未被引用的内存并不需要消耗很大的资源，但是保持并不断更新引用计数却代价不菲。</p><p>使用引用计数方式执行垃圾回收的主要困难在于保持引用计数的准确性，而另一个众所周知的问题在于解决循环引用结构所带来的麻烦。如果两个对象互相引用，并且没有其他存活东西引用它们，那么这两个对象所占用的内存将永远不会被释放，两个对象都会因引用计数不为0而永远存活下去。要解决循环引用带来的问题需要，而这会使算法复杂度增加，从而影响应用程序的运行性能。</p><p><strong>引用跟踪垃圾回收</strong></p><p>引用跟踪垃圾回收器基于这样一种假设，所有存活对象都可以通过迭代地跟踪从已知存活对象集中对象发出的引用及引用的引用来找到。可以通过对寄存器、全局域、以及触发垃圾回收时栈帧的分析来确定初始存活对象的集合（称为“根对象”，或简称为“根”）。在确定了初始存活对象集后，引用跟踪垃圾回收器会跟踪从这些对象中发出的引用，并将找到的对象标记为“活的（live）”。标记所有找到的对象意味着已知存活对象的集合会随时间而增长。这个过程会一直持续到所有被引用的对象（因此是“存活的”对象）都被标记。当引用跟踪垃圾回收器找到所有存活的对象后，就会开始回收未被标记的对象。</p><p>不同于引用计数垃圾回收器，引用跟踪垃圾回收器可以解决循环引用的问题。由于标记阶段的存在，大多数引用跟踪垃圾回收器无法立即释放“已死”对象所占用的内存。</p><p>引用跟踪垃圾回收器广泛用于动态语言的内存管理；到目前为止，在Java编程语言的视线中也是应用最广的，并且在多年的商业生产环境中，已经证明其实用性。在本文余下的内容中，我将从一些相关的实现算法开始，介绍引用跟踪垃圾回收器，</p><p><strong>引用跟踪垃圾回收器算法</strong></p><p>拷贝和<em>标记-清理</em>垃圾回收算法并非新近发明，但仍然是当今实现引用跟踪垃圾回收器最常用的两种算法。</p><p><strong>拷贝垃圾回收器</strong></p><p>传统的拷贝垃圾回收器会使用一个“from”区和一个“to”区，它们是堆中两个不同的地址空间。在执行垃圾回收时，from区中存活对象会被拷贝到to区。当from区中所有的存活对象都被拷贝到to后，垃圾回收器会回收整个from区。当再次分配内存时，会首先从to区中的空闲地址开始分配。</p><p>在该算法的早期实现中，from区和to区会在垃圾回收周期后进行交换，即当to区被填满后，将再次启动垃圾回收，这是to区会“变成”from区。如图Figure 1所示。</p><p><img src="http://osapnihnq.bkt.clouddn.com/blog/180420/kID01gDhm7.png?imageslim" alt="mark"><br>Figure 1. A traditional copying garbage collection sequence</p><p>在该算法的近期实现中，可以将堆中任意地址空间指定为from区和to区，这样就不再需要交换from区和to区，堆中任意地址空间都可以成为from区或to区。</p><p>拷贝垃圾回收器的一个优点是存活对象的位置会被to区中重新分配，紧凑存放，可以完全消除碎片化。碎片化是其他垃圾回收算法所要面临的一大问题，这点会在后续讨论。</p><p><strong>拷贝垃圾回收的缺陷</strong></p><p>通常来说，拷贝垃圾回收器是“stop-the-world”式的，即在垃圾回收周期内，应用程序是被挂起的，无法工作。在“stop-the-world”式的实现中，所需要拷贝的区域越大，对应用程序的性能所造成的影响也越大。对于那些非常注重响应时间的应用程序来说，这是难以接受的。使用拷贝垃圾回收时，你还需要考虑一下最坏情况，即当from区中所有的对象都是存活对象的时候。因此，你不得不给存活对象预留出足够的空间，也就是说to区必须足够大，大到可以将from区中所有的对象都放进去。正是由于这个缺陷，拷贝垃圾回收算法在内存使用效率上略有不足。</p><p><strong>标记-清理垃圾回收器</strong></p><p>大多数部署在企业生产环境的商业JVM都使用了标记-清理（或标记）垃圾回收器，这种垃圾回收器并不会想拷贝垃圾回收器那样对应用程序的性能有那么大的影响。其中最著名的几款是CMS、G1、GenPar和DeterministicGC（参见<a href="https://github.com/caoxudong/translation/blob/master/java/jvm/JVM_performance_optimization_Part_3_Garbage_collection.md#resources" target="_blank" rel="noopener">相关资源</a>）。<br>标记-清理垃圾回收器会跟踪引用，并使用标记位将每个找到的对象标记位“live”。通常来说，每个标记位都关联着一个地址或堆上的一个地址集合。例如，标记位可能是对象头（object header）中一位，一个位向量，或是一个位图。</p><p>当所有的存活对象都被标记位“live”后，将会开始<em>清理</em>阶段。一般来说，垃圾回收器的清理阶段包含了通过再次遍历堆（不仅仅是标记位live的对象集合，而是整个堆）来定位内存地址空间中未被标记的区域，并将其回收。然后，垃圾回收器会将这些被回收的区域保存到空闲列表（free list）中。在垃圾回收器中可以同时存在多个空闲列表——通常会按照保存的内存块的大小进行划分。某些JVM（例如JRockit实时系统， JRockit Real Time System）在实现垃圾回收器时会给予应用程序分析数据和对象大小统计数据来动态调整空闲列表所保存的区域块的大小范围。</p><p>当清理阶段结束后，应用程序就可以再次启动了。给新创建的对象分配内存时会从空闲列表中查找，而空闲列表中内存块的大小需要匹配于新创建的对象大小、某个线程中平均对象大小，或应用程序所设置的TLAB的大小。从空闲列表中为新创建的对象找到大小合适的内存区域块有助于优化内存的使用，减少内存中的碎片。</p><p><strong>标记-清理垃圾回收器的缺陷</strong></p><p>标记阶段的时长取决于堆中存活对象的总量，而清理阶段的时长则依赖于堆的大小。由于在<em>标记</em>阶段和<em>清理</em>阶段完成前，你无事可做，因此对于那些具有较大的堆和较多存活对象的应用程序来说，使用此算法需要想办法解决暂停时间（pause-time）较长这个问题。<br>对于那些内存消耗较大的应用程序来说，你可以使用一些GC调优选项来满足其在某些场景下的特殊需求。很多时候，调优至少可以将标记-清理阶段给应用程序或性能要求（SLA，SLA指定了应用程序需要达到的响应时间的要求，即延迟）所带来的风险推后。当负载和应用程序发生改变后，需要重新调优，因为某次调优只对特定的工作负载和内存分配速率有效。</p><p><strong>标记-清理算法的实现</strong></p><p>目前，标记-清理垃圾回收算法至少已有2种商业实现，并且都已在生产环境中被证明有效。其一是并行垃圾回收，另一个是并发（或多数时间并发）垃圾回收。</p><p><strong>并行垃圾回收器</strong></p><p>并行垃圾回收指的是垃圾回收是多线程并行完成的。大多数商业实现的并行垃圾回收器都是stop-the-world式的垃圾回收器，即在整个垃圾回收周期结束前，所有应用程序线程都会被挂起。挂起所有应用程序线程使垃圾回收器可以以并行的方式，更有效的完成标记和清理工作。并行使得效率大大提高，通常可以在像<a href="http://www.spec.org/jbb2005/" target="_blank" rel="noopener">SPECjbb</a>这样的吞吐量基准测试中跑出高分。如果你的应用程序好似有限考虑吞吐量的，那么并行垃圾回收是你最好的选择。</p><p>对于大多数并行垃圾回收器来说，尤其是考虑到应用于生产环境中，最大的问题是，像拷贝垃圾回收算法一样，在垃圾回收周期内应用程序无法工作。使用stop-the-world式的并行垃圾回收会对优先考虑响应时间的应用程序产生较大影响，尤其是当你有大量的引用需要跟踪，而此时恰好又有大量的、具有复杂结构的对象存活于堆中的时候，情况将更加糟糕。（记住，标记-清理垃圾回收器回收内存的时间取决于跟踪存活对象中所有引用的时间与遍历整个堆的时间之和。）以并行方式执行垃圾回收所导致的应用程序暂停会一直持续到整个垃圾回收周期结束。</p><p><strong>并发垃圾回收器</strong></p><p>并发垃圾回收器更适用于那些对响应时间比较敏感的应用程序。并发指的是一些（或大多数）垃圾回收工作可以与应用程序线程同时运行。由于并非所有的资源都由垃圾回收器使用，因此这里所面临的问题如何决定何时开始执行垃圾回收，可以保证垃圾回收顺利完成。这里需要足够的时间来跟踪存活对象即的引用，并在应用程序出现OOM错误前回收内存。如果垃圾回收器无法及时完成，则应用程序就会抛出OOM错误。此外，一直做垃圾回收也不好，会不必要的消耗应用程序资源，从而影响应用程序吞吐量。要想在动态环境中保持这种平衡就需要一些技巧，因此设计了启发式方法来决定何时开始垃圾回收，何时执行不同的垃圾回收优化任务，以及一次执行多少垃圾回收优化任务等。</p><p>并发垃圾回收器所面临的另一个挑战是如何决定何时执行一个需要完整堆快照的操作时安全的，例如，你需要知道是何时标记所有存活对象的，这样才能转而进入清理阶段。在大多数并行垃圾回收器采用的stop-the-world方式中，<em>阶段转换（phase-switching）</em>并不需要什么技巧，因为世界已静止（堆上对象暂时不会发生变化）。但是，在并发垃圾回收中，转换阶段时可能并不是安全的。例如，如果应用程序修改了一块垃圾回收器已经标记过的区域，可能会涉及到一些新的或未被标记的引用，而这些引用使其指向的对象成为存活状态。在某些并发垃圾回收的实现中，这种情况有可能会使应用程序陷入长时间运行重标记（re-mark）的循环，因此当应用程序需要分配内存时无法得到足够做的空闲内存。</p><p>到目前为止的讨论中，已经介绍了各种垃圾回收器和垃圾回收算法，他们各自适用于不同的场景，满足不同应用程序的需求。各种垃圾回收方式不仅在算法上有所区别，在具体实现上也不尽相同。所以，在命令行中指定垃圾回收器之前，最好能了解应用程序的需求及其自身特点。在下一节中，将介绍Java平台内存模型中的陷阱，在这里，陷阱指的是在动态生产环境中，Java程序员常常做出的一些中使性能更糟，而非更好的假设。</p><p><strong>为什么调优无法取代垃圾回收</strong></p><p>大多数Java程序员都知道，如果有不少方法可以最大化Java程序的性能。而当今众多的JVM实现，垃圾回收器实现，以及多到令人头晕的调优选项都可能会让开发人员将大量的时间消耗在无穷无尽的性能调优上。这种情况催生了这样一种结论，“GC是糟糕的，努力调优以降低GC的频率或时长才是王道”。但是，真这么做是有风险的。</p><p>考虑一下针对指定的应用程序需求做调优意味着什么。大多数调优参数，如内存分配速率，对象大小，响应时间，以及对象死亡速度等，都是针对特定的情况而来设定的，例如测试环境下的工作负载。例如。调优结果可能有以下两种：</p><ol><li>测试时正常，上线就失败。</li><li>一旦应用程序本身，或工作负载发生改变，就需要全部重调。</li></ol><p>调优是需要不断往复的。使用并发垃圾回收器需要做很多调优工作，尤其是在生产环境中。为满足应用程序的需求，你需要不断挑战可能要面对的最差情况。这样做的结果就是，最终形成的配置非常刻板，而且在这个过程中也浪费了大量的资源。这种调优方式（试图通过调优来消除GC）是一种堂吉诃德式的探索——以根本不存在的理由去挑战一个假想敌。而事实是，你针对某个特定的负载而垃圾回收器做的调优越多，你距离Java运行时的动态特性就越远。毕竟，有多少应用程序的工作负载能保持不变呢？你所预估的工作负载的可靠性又有多高呢？</p><p>那么，如果不从调优入手又该怎么办呢？有什么其他的办法可以防止应用程序出现OOM错误，并降低响应时间呢？这里，首先要做的是明确影响Java应用程序性能的真正因素。</p><p><strong>碎片化</strong></p><p>影响Java应用程序性能的罪魁祸首并不是垃圾回收器本身，而是碎片化，以及垃圾回收器如何处理碎片。碎片是Java堆中空闲空间，但由于连续空间不够大而无法容纳将要创建的对象。正如我在本系列<a href="https://github.com/chiyuanbo/cyb-mds/blob/master/java/jvm/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%202%20%E2%80%95%E2%80%95%20%E7%BC%96%E8%AF%91%E5%99%A8.md" target="_blank" rel="noopener">第2篇</a>中提到的，碎片可能是TLAB中的剩余空间，也可能是（这种情况比较多）被释放掉的具有较长生命周期的小对象所占用的空间。</p><p>随着应用程序的运行，这种无法使用的碎片会遍布于整个堆空间。在某些情况下，这种状态会因静态调优选项（如提升速率和空闲列表等）更糟糕，以至于无法满足应用程序的原定需求。这些剩下的空间（也就是碎片）无法被应用程序有效利用起来。如果你对此放任自流，就会导致不断垃圾回收，垃圾回收器会不断的释放内存以便创建新对象时使用。在最差情况下，甚至垃圾回收也无法腾出足够的内存空间（因为碎片太多），JVM会强制抛出OOM（out of memory）错误当然，你也可以重启应用程序来消除碎片，这样可以使Java堆焕然一新，于是就又可以为对象分配内存了。但是，重新启动会导致服务器停机，另外，一段时间之后，堆将再次充满碎片，你也不得不再次重启。</p><p>OOM错误（OutOfMemoryErrors）会挂起进程，日志中显示的垃圾回收器很忙，是垃圾回收器努力释放内存的标志，也说明了堆中碎片非常多。一些开发人员通过重新调优垃圾回收器来解决碎片化的问题，但我觉着在解决碎片问题成为垃圾回收的使命之前应该用一些更有新意的方法来解决这个问题。本文后面的内容将聚焦于能有效解决碎片化问题的方法：分代黛式垃圾回收和压缩。</p><p><strong>分代式垃圾回收</strong></p><p>这个理论你可以已经听说过，即在生产环境中，大部分对象的生命周期都很短。分代式垃圾回收就源于这个理论。在分代式垃圾回收中，堆被分为两个不同的空间（或成为“代”），每个空间存放具有不同年龄的对象，在这里，年龄是指该对象所经历的垃圾回收的次数（也就是该对象挺过了多少次垃圾回收而没有死掉）。</p><p>当新创建的对象所处的空间，即<em>年轻代</em>，被对象填满后，该空间中仍然存活的对象会被移动到老年代。（译者注，以HotSpot为例，这里应该是挺过若干次GC而不死的，才会被搬到老年代，而一些比较大的对象会直接放到老年代。）大多数的实现都将堆会分为两代，年轻代和老年代。通常来说，分代式垃圾回收器都是单向拷贝的，即从年轻代向老年代拷贝，这点在早先曾讨论过。近几年出现的年轻代垃圾回收器已经可以实现并行垃圾回收，当然也可以实现一些其他的垃圾回收算法实现对年轻代和老年代的垃圾回收。如果你使用拷贝垃圾回收器（可能具有并行收集功能）对年轻代进行垃圾回收，那垃圾回收是stop-the-world式的（参见前面的解释）。</p><p><strong>分代式垃圾回收的缺陷</strong></p><p>在分代式垃圾回收中，老年代执行垃圾回收的平率较低，而年轻代中较高，垃圾回收的时间较短，侵入性也较低。但在某些情况下，年轻代的存在会是老年代的垃圾回收更加频繁。典型的例子是，相比于Java堆的大小，年轻代被设置的太大，而应用程序中对象的生命周期又很长（又或者给年轻代对象提升速率设了一个“不正确”的值）。在这种情况下，老年代因太小而放不下所有的存活对象，因此垃圾回收器就会忙于释放内存以便存放从年轻代提升上来的对象。但一般来说，使用分代式垃圾回收器可以使用应用程序的性能和系统延迟保持在一个合适的水平。</p><p>使用分代式垃圾回收器的一个额外效果是部分解决了碎片化的问题，或者说，发生最差情况的时间被推迟了。可能造成碎片的小对象被分配于年轻代，也在年轻代被释放掉。老年代中的对象分布会相对紧凑一些，因为这些对象在从年轻代中提升上来的时候会被会紧凑存放。但随着应用程序的运行，如果运行时间够长的话，老年代也会充满碎片的。这时就需要对年轻代和老年代执行一次或多次stop-the-world式的全垃圾回收，导致JVM抛出<em>OOM错误</em>或者表明提升失败的错误。但年轻代的存在使这种情况的出现被推迟了，对某些应用程序来说，这就就足够了。（在某些情况下，这种糟糕情况会被推迟到应用程序完全不关心GC的时候。）对大多数应用程序来说，对于大多数使用年轻代作为缓冲的应用程序来说，年轻代的存在可以降低出现stop-the-world式垃圾回收频率，减少抛出OOM错误的次数。</p><p><strong> 调优分代式垃圾回收</strong></p><p>正如上面提到的，由于使用了分代式垃圾回收，你需要针对每个新版本的应用程序和不同的工作负载来调整年轻代大小和对象提升速度。我无法完整评估出固定运行时的代价：由于针对某个指定工作负载而设置了一系列优化参数，垃圾回收器应对动态变化的能力降低了，而变化是不可避免的。</p><p>对于调整年轻代大小来说，最重要的规则是要确保年轻代的大小不应该使因执行stop-the-world式垃圾回收而导致的暂停过长。（假设年轻代中使用的并行垃圾回收器。）还要记住的是，你要在堆中为老年代留出足够的空间来存放那些生命周期较长的对象。下面还有一些在调优分代式垃圾回收器时需要考虑的因素：</p><ol><li><p>大多数年轻代垃圾回收都是stop-the-world式的，年轻代越大，相应的暂停时间越长。所以，对于那些受GC暂停影响较大的应用程序来说，应该仔细斟酌年轻代的大小。</p></li><li><p>你可以综合考虑不同代的垃圾回收算法。可以在年轻代使用并行垃圾回收，而在老年代使用并行垃圾回收。</p></li><li><p>当提升失败频繁发生时，这通常说明老年代中的碎片较多。提升失败指的是老年代中没有足够大的空间来存放年轻代中的存活对象。当出现提示失败时，你可以微调对象提升速率（即调整对象提升时年龄），或者确保老年代垃圾回收算法会将对象进行压缩（将在下一节讨论），并以一种适合当前应用程序工作负载的方式调整压缩。你也可以增大堆和各个代的大小，但这会使老年代垃圾回收的暂停时间延长——记住，碎片化是不可避免的。</p></li><li><p>分代式垃圾回收最适用于那些具有大量短生命周期对象的应用程序，这些对象的生命周期短到活不过一次垃圾回收周期。在这种场景中，分代式垃圾回收可有效的减缓碎片化的趋势，主要是将碎片化随带来的影响推出到将来，而那时可能应用程序对此毫不关心。</p></li></ol><p><strong>压缩</strong></p><p>尽管分代式垃圾回收推出了碎片化和OOM错误出现的时机，但压缩仍然是唯一真正解决碎片化的方法。<em>压缩</em>是将对象移动到一起，以便释放掉大块连续内存空间的GC策略。因此，压缩可以生成足够大的空间来存放新创建的对象。</p><p>移动对象并修改相关引用是一个stop-the-world式的操作，这会对应用程序的性能造成影响。（只有一种情况是个例外，将在本系列的下一篇文章中讨论。）存活对象越多，垃圾回收造成的暂停也越长。假如堆中的空间所剩无几，而且碎片化又比较严重（这通常是由于应用程序运行的时间很长了），那么对一块存活对象多的区域进行压缩可能会耗费数秒的时间。而如果因出现OOM而导致应用程序无法运行，因此而对整个堆进行压缩时，所消耗的时间可达数十秒。</p><p>压缩导致的暂停时间的长短取决于需要移动的存活对象所占用的内存有多大以及有多少引用需要更新。当堆比较大时，从统计上讲，存活对象和需要更新的引用都会很多。从已观察到的数据看，每压缩1到2GB存活数据的需要约1秒钟。所以，对于4GB的堆来说，很可能会有至少25%的存活数据，从而导致约1秒钟的暂停。</p><p><strong>压缩与应用程序内存墙</strong></p><p>应用程序内存墙涉及到在GC暂停时间对应用程序的影响大到无法达到满足预定需求之前所能设置的的堆的最大值。目前，大部分Java应用程序在碰到内存墙时，每个JVM实例的堆大小介于4GB到20GB之间，具体数值依赖于具体的环境和应用程序本身。这也是大多数企业及应用程序会部署多个小堆JVM而不是部署少数大堆（50到60GB）JVM的原因之一。在这里，我们需要思考一下：现代企业中有多少Java应用程序的设计与部署架构受制于JVM中的压缩？在这种情况下，我们接受多个小实例的部署方案，以增加管理维护时间为代价，绕开为处理充满碎片的堆而执行stop-the-world式垃圾回收所带来的问题。考虑到现今的硬件性能和企业级Java应用程序中对内存越来越多的访问要求，这种方案是在非常奇怪。为什么仅仅只能给每个JVM实例设置这么小的堆？并发压缩是一种可选方法，它可以降低内存墙带来的影响，这将是本系列中下一篇文章的主题。</p><p>从已观察到的数据看，每压缩1到2GB存活数据的需要约1秒钟。所以，对于4GB的堆来说，很可能会有至少25%的存活数据，从而导致约1秒钟的暂停。</p><p><strong>总结：回顾</strong></p><p>本文对垃圾回收做了总体介绍，目的是为了使你能了解垃圾回收的相关概念和基本知识。希望本文能激发你继续深入阅读相关文章的兴趣。这里所介绍的大部分内容，它们。在下一篇文章中，我将介绍一些较新颖的概念，并发压缩，目前只有Azul公司的Zing JVM实现了这一技术。并发压缩是对GC技术的综合运用，这些技术试图重新构建Java内存模型，考虑当今内存容量与处理能力的不断提升，这一点尤为重要。</p><p>现在，回顾一下本文中所介绍的关于垃圾回收的一些内容：</p><ol><li><p>不同的垃圾回收算法的方式是为满足不同的应用程序需求而设计。目前在商业环境中，应用最为广泛的是引用跟踪垃圾回收器。</p></li><li><p>并行垃圾回收器会并行使用可用资源执行垃圾回收任务。这种策略的常用实现是stop-the-world式垃圾回收器，使用所有可用系统资源快速完成垃圾回收任务。因此，并行垃圾回收可以提供较高的吞吐量，但在垃圾回收的过程中，所有应用程序线程都会被挂起，对延迟有较大影响。</p></li><li><p>并发垃圾回收器可以与应用程序并发工作。使用并发垃圾回收器时要注意的是，确保在应用程序发生OOM错误之前完成垃圾回收。</p></li><li><p>分代式垃圾回收可以推迟碎片化的出现，但并不能消除碎片化。它将堆分为两块空间，一块用于存放“年轻对象”，另一块用于存放从年轻代中存活下来的存活对象。对于那些使用了很多具有较短生命周期活不过几次垃圾回收周期的Java应用程序来说，使用分代式垃圾回收是非常合适的。</p></li><li><p>压缩是可以完全解决碎片化的唯一方法。大多数垃圾回收器在压缩的时候是都stop-the-world式的。应用程序运行的时间越长，对象间的引就用越复杂，对象大小的异质性也越高。相应的，完成压缩所需要的时间也越长。如果堆的大小较大的话也会对压缩所占产生的暂停有影响，因为较大的堆就会有更多的活动数据和更多的引用需要处理。</p></li><li><p>调优可以推迟OOM错误的出现，但过度调优是无意义的。在通过试错方式初始调优前，一定要明确生产环境负载的动态性，以及应用程序中的对象类型和对象间的引用情况。在动态负载下，过于刻板的配置很容会失效。在设置非动态调优选项前一定要清楚这样做后果。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 作者：Eva Andreasson,译者：曹旭东 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM性能优化， Part 2 ―― 编译器</title>
      <link href="/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%202%20%E2%80%95%E2%80%95%20%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%202%20%E2%80%95%E2%80%95%20%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>[toc]</p><p><strong>什么是编译器</strong></p><p>简单来说，编译器就是将一种编程语言作为输入，输出另一种可执行语言的工具。大家都熟悉的javac就是一个编译器，所有标准版的JDK中都带有这个工具。javac以Java源代码作为输入，将其翻译为可由JVM执行的字节码。翻译后的字节码存储在.class文件中，在启动Java进程的时候，被载入到Java运行时中。</p><p>标准CPU并不能识别字节码，它需要被转换为当前平台所能理解的本地指令。在JVM中，有专门的组件负责将字节码编译为平台相关指令，实际上，这也是一种编译器。有些JVM编译器可以处理多层级的编译工作，例如，编译器在最终将字节码转换为平台相关指令前，会为相关的字节码建立多层级的中间表示（intermediate representation）。</p><p><em>字节码与JVM</em></p><p>如果你想了解更多有关字节码与JVM的信息，请阅读 <a href="http://www.javaworld.com/javaworld/jw-09-1996/jw-09-bytecodes.html" target="_blank" rel="noopener">“Bytecode basics”</a>(Bill Venners, JavaWorld)</p><p>以平台未知的角度看，我们希望尽可能的保持平台独立性，因此，最后一级的编译，也就是从最低级表示到实际机器码的转换，是与具体平台的处理器架构息息相关的。在最高级的表示上，会因使用静态编译器还是动态编译器而有所区别。在这里，我们可以选择应用程序所以来的可执行环境，期望达到的性能要求，以及我们所面临的资源限制。在本系列的第1篇文章的<a href="http://www.javaworld.com/javaworld/jw-08-2012/120821-jvm-performance-optimization-overview.html" target="_blank" rel="noopener">静态编译器与动态编译器</a>一节中，已经对此有过简要介绍。我将在本文的后续章节中详细介绍这部分内容。</p><p><strong>静态编译器与动态编译器</strong></p><p>前文提到的javac就是使用静态编译器的例子。静态编译器解释输入的源代码，并输出程序运行时所需的可执行文件。如果你修改了源代码，那么就需要使用编译器来重新编译代码，否则输出的可执行性文件不会发生变化；这是因为静态编译器的输入是静态的普通文件。</p><p>使用静态编译器时，下面的Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add7</span><span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会生成类似如下的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iload0</span><br><span class="line">bipush <span class="number">7</span></span><br><span class="line">iadd</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure><p>动态编译器会动态的将一种编程语言编译为另一种，即在程序运行时执行编译工作。动态编译与优化使运行时可以根据当前应用程序的负载情况而做出相应的调整。动态编译器非常适合用于Java运行时中，因为Java运行时通常运行在无法预测而又会随着运行而有所变动的环境中。大部分JVM都会使用诸如Just-In-Time编译器的动态编译器。这里面需要注意的是，大部分动态编译器和代码优化有时需要使用额外的数据结构、线程和CPU资源。要做的优化或字节码上下文分析越高级，编译过程所消耗的资源就越多。在大多数运行环境中，相比于经过动态编译和代码优化所获得的性能提升，这些损耗微不足道。</p><p><strong>_ JVM的多样性与Java平台的独立性_</strong></p><p>所有的JVM实现都有一个共同点，即它们都试图将应用程序的字节码转换为本地机器指令。一些JVM在载入应用程序后会解释执行应用程序，同时使用性能计数器来查找“热点”代码。还有一些JVM会调用解释执行的阶段，直接编译运行。资源密集型编译任务对应用程序来说可能会产生较大影响，尤其是那些客户端模式下运行的应用程序，但是资源密集型编译任务可以执行一些比较高级的优化任务。更多相关内容请参见<a href="https://github.com/caoxudong/translation/blob/master/java/jvm/JVM_performance_optimization_Part_2_Compilers.md#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">相关资源</a></p><p>如果你是Java初学者，JVM本身错综复杂结构会让你晕头转向的。不过，好消息是你无需精通JVM。JVM自己会做好代码编译和优化的工作，所以你无需关心如何针对目标平台架构来编写应用程序才能编译、优化，从而生成更好的本地机器指令。</p><p><strong>从字节码到可运行的程序</strong></p><p>当你编写完Java源代码并将之编译为字节码后，下一步就是将字节码指令编译为本地机器指令。这一步会由解释器或编译器完成。</p><p><strong>解释</strong></p><p>解释是最简单的字节码编译形式。解释器查找每条字节码指令对应的硬件指令，再由CPU执行相应的硬件指令。</p><p>你可以将解释器想象为一个字典：每个单词（字节码指令）都有准确的解释（本地机器指令）。由于解释器每次读取一个字节码指令并立即执行，因此它就没有机会对某个指令集合进行优化。由于每次执行字节码时，解释器都需要做相应的解释工作，因此程序运行起来就很慢。解释执行可以准确执行字节码，但是未经优化而输出的指令集难以发挥目标平台处理器的最佳性能。</p><p><strong>编译</strong></p><p>另一方面，编译执行应用程序时，<em>编译器</em>会将加载运行时会用到的全部代码。因为编译器可以将字节码编译为本地代码，因此它可以获取到完整或部分运行时上下文信息，并依据收集到的信息决定到底应该如何编译字节码。编译器是根据诸如指令的不同执行分支和运行时上下文数据等代码信息来指定决策的。</p><p>当字节码序列被编译为机器代码指令集合时，就可以对这个指令集合做一些优化操作了，优化后的指令集合会被存储到成为code cache的数据结构中。当下一次执行这部分字节码序列时，就会执行这些经过优化后被存储到code cache的指令集合。在某些情况下，性能计数器会失效，并覆盖掉先前所做的优化，这时，编译器会执行一次新的优化过程。使用code cache的好处是优化后的指令集可以立即执行 —— 无需像解释器一样再经过查找的过程或编译过程！这可以加速程序运行，尤其是像Java应用程序这种同一个方法会被多次调用应用程序。</p><p><strong>优化</strong></p><p>随着动态编译器一起出现的是性能计数器。例如，编译器会插入性能计数器，以统计每个字节码块（对应与某个被调用的方法）的调用次数。在进行相关优化时，编译器会使用收集到的数据来判断某个字节码块有多“热”，这样可以最大程度的降低对当前应用程序的影响。运行时数据监控有助于编译器完成多种代码优化工作，进一步提升代码执行性能。随着收集到的运行时数据越来越多，编译器就可以完成一些额外的、更加复杂的代码优化工作，例如编译出更高质量的目标代码，使用运行效率更高的代码替换原代码，甚至是剔除冗余操作等。</p><p><strong>示例</strong></p><p>考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add7</span><span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x+<span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码经过javac编译后会产生如下的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iload0</span><br><span class="line">bipush <span class="number">7</span></span><br><span class="line">iadd</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure><p>当调用这段代码时，字节码块会被动态的编译为本地机器指令。当性能计数器（如果这段代码应用了性能计数器的话）发现这段代码的运行次数超过了某个阈值后，动态编译器会对这段代码进行优化编译。后带的代码可能会是下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea rax,[rdx+<span class="number">7</span>]</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>各擅胜场</strong></p><p>不同的Java应用程序需要满足不同的需求。相对来说，企业级服务器端应用程序需要长时间运行，因此可以做更多的优化，而稍小点的客户端应用程序可能要求快速启动运行，占资源少。接下来我们考察三种编译器设置及其各自的优缺点。</p><p><strong>客户端编译器</strong></p><p>即大家熟知的优化编译器C1。在启动应用程序时，添加JVM启动参数“-client”可以启用C1编译器。正如启动参数所表示的，C1是一个客户端编译器，它专为客户端应用程序而设计，资源消耗更少，并且在大多数情况下，对应用程序的启动时间很敏感。C1编译器使用性能计数器来收集代码的运行时信息，执行一些简单、无侵入的代码优化任务。</p><p><strong>服务器端编译器</strong></p><p>对于那些需要长时间运行的应用程序，例如服务器端的企业级Java应用程序来说，客户端编译器所实现的功能还略有不足，因此服务器端的编译会使用类似C2这类的编译器。启动应用程序时添加命令行参数“-server”可以启用C2编译器。由于大多数服务器端应用程序都会长时间运行，因此相对于运行时间稍短的轻量级客户端应用程序，在服务器端应用程序中启用C2编译器可以收集到更多的运行时数据，也就可以执行一些更高级的编译技术与算法。</p><p><strong><em>提示：给服务器端编译器热身</em></strong></p><p>对于服务器端编译器来说，在应用程序开始运行之后，编译器可能会在一段时间之后才开始优化“热点”代码，所以服务器端编译器通常需要经过一个“热身”阶段。在服务器端编译器执行性能优化任务之前，要确保应用程序的各项准备工作都已就绪。给予编译器足够多的时间来完成编译、优化的工作才能取得更好的效果。（更多关于编译器热身与监控原理的内容请参见JavaWorld的文章”<a href="http://www.javaworld.com/javaqa/2003-04/01-qa-0411-hotspot.html" target="_blank" rel="noopener">Watch your HotSpot compiler go</a>“。）</p><p>在执行编译任务优化任务时，服务器端编译器要比客户端编译器综合考虑更多的运行时信息，执行更复杂的分支分析，即对哪种优化路径能取得更好的效果作出判断。获取的运行时数据越多，编译优化所产生的效果越好。当然，要完成一些复杂的、高级的性能分析任务，编译器就需要消耗更多的资源。使用了C2编译器的JVM会消耗更多的资源，例如更多的线程，更多的CPU指令周期，以及更大的code cache等。</p><p><strong>层次编译</strong></p><p>层次编译综合了服务器端编译器和客户端编译器的特点。Azul首先在其Zing JVM中实现了层次编译。最近（就是Java SE 7版本），Oracle Java HotSpot VM也采用了这种设计。在应用程序启动阶段，客户端编译器最为活跃，执行一些由较低的性能计数器阈值出发的性能优化任务。此外，客户端编译器还会插入性能计数器，为一些更复杂的性能优化任务准备指令集，这些任务将在后续的阶段中由服务器端编译器完成。层次编译可以更有效的利用资源，因为编译器在执行一些对应用程序影响较小的编译活动时仍可以继续收集运行时信息，而这些信息可以在将来用于完成更高级的优化任务。使用层次编译可以比解释性的代码性能计数器手机到更多的信息。</p><p>Figure 1中展示了纯解释运行、客户端模式运行、服务器端模式运行和层次编译模式运行下性能之间的区别。X轴表示运行时间（单位时间）Y轴表示性能（每单位时间内的操作数）。</p><p><img src="http://osapnihnq.bkt.clouddn.com/blog/180420/5Gkal6f7F3.png?imageslim" alt="mark"></p><p>Figure 1. Performance differences between compilers (click to enlarge)</p><p><strong>编译性能对比</strong></p><p>相比于纯解释运行的的代码，以客户端模式编译运行的代码在性能（指单位时间执行的操作）上可以达到约5到10倍，因此而提升了应用程序的运行性能。其间的区别主要在于编译器的效率、编译器所作的优化，以及应用程序在设计实现时针对目标平台做了何种程度的优化。实际上，最后一条不在Java程序员的考虑之列。</p><p>相比于客户端编译器，使用服务器端编译器通常会有30%到50%的性能提升。在大多数情况下，这种程度的性能提升足以弥补使用服务器端编译所带来的额外资源消耗。</p><p>层次编译综合了服务器端编译器和客户端编译器的优点，使用客户端编译模式实现快速启动和快速优化，使用服务器端编译模式在后续的执行周期中完成高级优化的编译任务。</p><p><strong>常用编译优化手段</strong></p><p>到目前为止，已经介绍了优化代码的价值，以及常用JVM编译器是如何以及何时编译代码的。接下来，将用一些实际的例子做个总结。JVM所作的性能优化通常在字节码这一层级（或者是更底层的语言表示），但这里我将使用Java编程语言对优化措施进行介绍。在这一节中，我无法涵盖JVM中所作的所有性能优化，相反，我希望可以激发你的兴趣，使你主动挖掘并学习编译器技术中所包含了数百种高级优化技术（参见相关资源）。</p><p><strong>死代码剔除</strong></p><p>死代码剔除指的是，将用于无法被调用的代码，即“死代码”，从源代码中剔除。如果编译器在运行时发现某些指令是不必要的，它会简单的将其从可执行指令集中剔除。例如，在Listing 1中，变量被赋予了确定值，却从未被使用，因此可以在执行时将其完全忽略掉。在字节码这一层级，也就不会有将数值载入到寄存器的操作。没有载入操作意味着可以更少的CPU时间，更好的运行性能，尤其是当这段代码是“热点”代码的时候。</p><p>Listing 1中展示了示例代码，其中被赋予了固定值的代码从未被使用，属于无用不必要的操作。</p><p>Listing 1. Dead code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeToScaleMyApp</span><span class="params">(<span class="keyword">boolean</span> endlessOfResources)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> reArchitect = <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">int</span> patchByClustering = <span class="number">15</span>;</span><br><span class="line">  <span class="keyword">int</span> useZing = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(endlessOfResources)</span><br><span class="line">      <span class="keyword">return</span> reArchitect + useZing;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> useZing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在字节码这一层级，如果变量被载入但从未使用，编译器会检测到并剔除这个死代码，如Listing 2所示。剔除死代码可以节省CPU时间，从而提升应用程序的运行速度。</p><p>Listing 2. The same code following optimization</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeToScaleMyApp</span><span class="params">(<span class="keyword">boolean</span> endlessOfResources)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> reArchitect = <span class="number">24</span>;</span><br><span class="line">  <span class="comment">//unnecessary operation removed here...</span></span><br><span class="line">  <span class="keyword">int</span> useZing = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(endlessOfResources)</span><br><span class="line">      <span class="keyword">return</span> reArchitect + useZing;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> useZing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冗余剔除是一种类似的优化手段，通过剔除掉重复的指令来提升应用程序性能。</p><p><strong>内联</strong></p><p>许多优化手段都试图消除机器级跳转指令（例如，x86架构的JMP指令）。跳转指令会修改指令指针寄存器，因此而改变了执行流程。相比于其他汇编指令，跳转指令是一个代价高昂的指令，这也是为什么大多数优化手段会试图减少甚至是消除跳转指令。内联是一种家喻户晓而且好评如潮的优化手段，这是因为跳转指令代价高昂，而内联技术可以将经常调用的、具有不容入口地址的小方法整合到调用方法中。Listing 3到Listing 5中的Java代码展示了使用内联的用法。</p><p>Listing 3. Caller method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whenToEvaluateZing</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> daysLeft(y) + daysLeft(<span class="number">0</span>) + daysLeft(y+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 4. Called method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysLeft</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 5. Inlined method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whenToEvaluateZing</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(y == <span class="number">0</span>) temp += <span class="number">0</span>; <span class="keyword">else</span> temp += y - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span> == <span class="number">0</span>) temp += <span class="number">0</span>; <span class="keyword">else</span> temp += <span class="number">0</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(y+<span class="number">1</span> == <span class="number">0</span>) temp += <span class="number">0</span>; <span class="keyword">else</span> temp += (y + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Listing 3到Listing 5的代码中，展示了将调用3次小方法进行内联的示例，这里我们认为使用内联比跳转有更多的优势。</p><p>如果被内联的方法本身就很少被调用的话，那么使用内联也没什么意义，但是对频繁调用的“热点”方法进行内联在性能上会有很大的提升。此外，经过内联处理后，就可以对内联后的代码进行进一步的优化，正如Listing 6中所展示的那样。</p><p>Listing 6. After inlining, more optimizations can be applied</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whenToEvaluateZing</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y == <span class="number">0</span>) <span class="keyword">return</span> y;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (y == -<span class="number">1</span>) <span class="keyword">return</span> y - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> y + y - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>循环优化</strong></p><p>当涉及到需要减少执行循环时的性能损耗时，循环优化起着举足轻重的作用。执行循环时的性能损耗包括代价高昂的跳转操作，大量的条件检查，和未经优化的指令流水线（即引起CPU空操作或额外周期的指令序列）等。循环优化可以分为很多种，在各种优化手段中占有重要比重。其中值得注意的包括以下几种：</p><ul><li><p>合并循环：当两个相邻循环的迭代次数相同时，编译器会尝试将两个循环体进行合并。当两个循环体中没有相互引用的情况，即各自独立时，可以同时执行（并行执行）。</p></li><li><p>反转循环：基本上将就是用do-while循环体换掉常规的while循环，这个do-while循环嵌套在if语句块中。这个替换操作可以节省两次跳转操作，但是，会增加一个条件检查的操作，因此增加的代码量。这种优化方式完美的展示了以少量增加代码量为代价换取较大性能的提升 —— 编译器需要在运行时需要权衡这种得与失，并制定编译策略。</p></li><li><p>分块循环：重新组织循环体，以便迭代数据块时，便于缓存的应用。</p></li><li><p>展开循环：减少判断循环条件和跳转的次数。你可以将之理解为将一些迭代的循环体“内联”到一起，而无需跨越循环条件。展开循环是有风险的，它有可能会降低应用程序的运行性能，因为它会影响流水线的运行，导致产生了冗余指令。再强调一遍，展开循环是编译器在运行时根据各种信息来决定是否使用的优化手段，如果有足够的收益的话，那么即使有些性能损耗也是值得的。</p></li></ul><p>至此，已经简要介绍了编译器对字节码层级（以及更底层）进行优化，以提升应用程序在目标平台的执行性能的几种方式。这里介绍的几种优化手段是比较常用的几种，只是众多优化技术中的几种。在介绍优化方法时配以简单示例和相关解释，希望可以洗发你进行深度探索的兴趣。更多相关内容请参见相关资源。</p><p><strong>总结：回顾</strong></p><p>为满足不同需要而使用不同的编译器。</p><ul><li>解释是将字节码转换为本地机器指令的最简单方式，其工作方式是基于对本地机器指令表的查找。</li><li>编译器可以基于性能计数器进行性能优化，但是需要消耗更多的资源（如code cache，优化线程等）。</li><li>相比于纯解释执行代码，客户端编译器可以将应用程序的执行性能提升一个数量级（约5到10倍）。</li><li>相比于客户端编译器，服务器端编译器可以将应用程序的执行性能提升30%到50%，但会消耗更多的资源。</li><li>层次编译综合了客户端编译器和服务器端编译器的优点，既可以像客户端编译器那样快速启动，又可以像服务器端编译器那样，在长时间收集运行时信息的基础上，优化应用程序的性能。</li></ul><p>目前，已经出现了很多代码优化的手段。对编译器来说，一个主要的任务就是分析所有的可能性，权衡使用某种优化手段的利弊，在此基础上编译代码，优化应用程序的性能。</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：Eva Andreasson,译者：曹旭东 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM性能优化， Part 1 ―― JVM简介</title>
      <link href="/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%201%20%E2%80%95%E2%80%95%20JVM%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/04/28/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%201%20%E2%80%95%E2%80%95%20JVM%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>[toc]</p><p>JVM性能调优：</p><ul><li>第一部分：概述</li><li>第二部分：编译工具</li><li>第三部分：垃圾回收</li><li>第四部分：并发压缩GC</li><li>第五部分：可扩展性</li></ul><h5 id="Java的性能与“一次编写，到处运行”的挑战"><a href="#Java的性能与“一次编写，到处运行”的挑战" class="headerlink" title="Java的性能与“一次编写，到处运行”的挑战"></a><strong>Java的性能与“一次编写，到处运行”的挑战</strong></h5><p>有不少人认为，Java平台本身就挺慢。其主要观点简单来说就是，Java性能低已经有些年头了 ―― 最早可以追溯到Java第一次用于企业级应用程序开发的时候。但这早就是老黄历了。事实是，如果你对不同的开发平台上运行简单的、静态的、确定性任务的运行结果做比较，你就会发现使用经过机器级优化（machine-optimized）代码的平台比任何使用虚拟环境进行运算的都要强，JVM也不例外。但是，在过去的10年中，Java的性能有了大幅提升。市场上不断增长的需求催生了垃圾回收算法的出现和编译技术的革新，在不断探索与优化的过程中，JVM茁壮成长。在这个系列文章中，我将介绍其中的一些内容。</p><p>JVM技术中最迷人的地方也正是其最具挑战性的地方：“一次编写，到处运行”。JVM并不对具体的用例、应用程序或用户负载进行优化，而是在应用程序运行过程中不断收集运行时信息，并以此为根据动态的进行优化。这种动态的运行时特性带来了很多动态问题。在设计优化方案时，以JVM为工作平台的程序无法依靠静态编译和可预测的内存分配速率（predictable allocation rates）对应用程序做性能评估，至少在对生产环境进行性能评估时是不行的。</p><p>机器级优化过的代码有时可以达到更好的性能，但它是以牺牲可移植性为代价的，在企业级应用程序中，动态负载和快速迭代更新是更加重要的。大多数企业会愿意牺牲一点机器级优化代码带来的性能，以此换取Java平台的诸多优势：</p><ul><li>编码简单，易于实现（意味着可以更快的推向市场）</li><li>有很多非常有才的程序员</li><li>使用Java API和标准库实现快速开发</li><li>可移植性 ―― 无需为每个平台都编写一套代码</li></ul><h5 id="从源代码到字节码"><a href="#从源代码到字节码" class="headerlink" title="从源代码到字节码"></a><strong>从源代码到字节码</strong></h5><p>作为一名Java程序员，你可以已经对编码、编译和运行这一套流程比较熟悉了。假如说，现在你写了一个程序代码MyApp.java，准备编译运行。为了运行这个程序，首先，你需要使用JDK内建的Java语言编译器，javac，对这个文件进行编译，它可以将Java源代码编译为字节码。javac将根据Java程序的源代码生成对应的可执行字节码，并将其保存为同名类文件：MyApp.class。在经过编译阶段后，你就可以在命令行中使用java命令或其他启动脚本载入可执行的类文件来运行程序，并且可以为程序添加启动参数。之后，类会被载入到运行时（这里指的是正在运行的JVM），程序开始运行。</p><p>上面所描述的就是在运行Java应用程序时的表面过程，但现在，我们要深入挖掘一下，在调用Java命令时，到底发生了什么？JVM到底是什么？大多数程序员是通过不断的调优，即使用相应的启动参数，与JVM进行交互，使Java程序运行的更快，同时避免程序出现“out of memory”错误。但你是否想过，为什么我们必须要通过JVM来运行Java应用程序呢？</p><h5 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a><strong>什么是JVM</strong></h5><p>简单来说，JVM是用于执行Java应用程序和字节码的软件模块，并且可以将字节码转换为特定硬件和特定操作系统的本地代码。正因如此，JVM使Java程序做到了“一次编写，到处运行”。Java语言的可移植性是得到企业级应用程序开发者青睐的关键：开发者无需因平台不同而把程序重新编写一遍，因为有JVM负责处理字节码到本地代码的转换和平台相关优化的工作。</p><blockquote><p>基本上来说，JVM是一个虚拟运行环境，对于字节码来说就像是一个机器一样，可以执行任务，并通过底层实现执行内存相关的操作。</p></blockquote><p>JVM也可以在运行java应用程序时，很好的管理动态资源。这指的是他可以正确的分配、回收内存，在不同的上维护一个具有一致性的线程模型，并且可以为当前的CPU架构组织可执行指令。JVM解放了程序员，使程序员不必再关系对象的生命周期，使程序员不必再关心应该在何时释放内存。而这，正是使用着类似C语言的非动态语言的程序员心中永远的痛。</p><p>你可以将JVM当做是一种专为Java而生的特殊的操作系统，它的工作是管理运行Java应用程序的运行时环境。简单来说，JVM就是运行字节码指令的虚拟执行环境，并且可以分配执行任务，或通过底层实现对内存进行操作。</p><h5 id="JVM组件简介"><a href="#JVM组件简介" class="headerlink" title="JVM组件简介"></a><strong>JVM组件简介</strong></h5><p>关于JVM内部原理与性能优化有很多内容可写。作为这个系列的开篇文章，我简单介绍JVM的内部组件。这个简要介绍对于那些JVM新手比较有帮助，也是为后面的深入讨论做个铺垫。</p><h5 id="从一种语言到另一种-――-关于Java编译器"><a href="#从一种语言到另一种-――-关于Java编译器" class="headerlink" title="从一种语言到另一种 ―― 关于Java编译器"></a><strong>从一种语言到另一种 ―― 关于Java编译器</strong></h5><p><code>编译器</code>以一种语言为输入，生成另一种可执行语言作为输出。Java编译器主要完成2个任务：</p><ol><li>实现Java语言的可移植性，不必局限于某一特定平台；</li><li>确保输出代码可以在目标平台能够有效率的运行。</li></ol><p>编译器可以是静态的，也可以是动态的。静态编译器，如javac，它以Java源代码为输入，将其编译为字节码（一种可以运行JVM中的语言）。<em>静态编译器</em>解释输入的源代码，而生成可执行输出代码则会在程序真正运行时用到。因为输入是静态的，所有输出结果总是相同的。只有当你修改的源代码并重新编译时，才有可能看到不同的编译结果。</p><p><em>动态编译器</em>，如使用<a href="https://github.com/caoxudong/translation/blob/master/java/jvm/JVM_performance_optimization_Part_1_A_JVM_technology_primer.md#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90" title="相关资源" target="_blank" rel="noopener">Just-In-Time(JIT，即时编译)</a>技术的编译器，会动态的将一种编程语言编译为另一种语言，这个过程是在程序运行中同时进行的。JIT编译器会收集程序的运行时数据（在程序中插入性能计数器），再根据运行时数据和当前运行环境数据动态规划编译方案。动态编译可以生成更好的序列指令，使用更有效率的指令集合替换原指令集合，或剔除冗余操作。收集到的运行时数据的越多，动态编译的效果就越好；这通常称为代码优化或重编译。</p><p>动态编译使你的程序可以应对在不同负载和行为下对新优化的需求。这也是为什么动态编译器非常适合Java运行时。这里需要注意的地方是，动态编译器需要动用额外的数据结构、线程资源和CPU指令周期，才能收集运行时信息和优化的工作。若想完成更高级点的优化工作，就需要更多的资源。但是在大多数运行环境中，相对于获得的性能提升来说，动态编译的带来的性能损耗其实是非常小的 ―― 动态编译后的代码的运行效率可以比纯解释执行（即按照字节码运行，不做任何修改）快5到10倍。</p><h5 id="内存分配与垃圾回收"><a href="#内存分配与垃圾回收" class="headerlink" title="内存分配与垃圾回收"></a><strong>内存分配与垃圾回收</strong></h5><p><code>内存分配</code>是以线程为单位，在“Java进程专有内存地址空间”中，也就是Java堆中分配的。在普通的客户端Java应用程序中，内存分配都是单线程进行的。但是，在企业级应用程序和服务器端应用程序中，单线程内存分配却并不是个好办法，因为它无法充分利用现代多核时代的并行特性。</p><p>并行应用程序设计要求JVM确保多线程内存分配不会在同一时间将同一块地址空间分配给多个线程。你可以在整个内存空间中加锁来解决这个问题，但是这个方法（即所谓的“堆锁”）开销较大，因为它迫使所有线程在分配内存时逐个执行，对资源利用和应用程序性能有较大影响。多核程序的一个额外特点是需要有新的资源分配方案，避免出现单线程、序列化资源分配的性能瓶颈。</p><p>常用的解决方案是将堆划分为几个区域，每个区域都有适当的大小，当然具体的大小需要根据实际情况做相应的调整，因为不同应用程序之间，内存分配速率、对象大小和线程数量的差别是非常大的。Thread Local Allocation Buffer（TLAB），有时也称为Thraed Local Area（TLA），是线程自己使用的专用内存分配区域，在使用的时候无需获取堆锁。当这个区域用满的时候，线程会申请新的区域，直到堆中所有预留的区域都用光了。当堆中没有足够的空间来分配内存时，堆就“满”了，即堆上剩余的空间装不下待分配空间的对象。当堆满了的时候，垃圾回收就开始了。</p><h5 id="碎片化"><a href="#碎片化" class="headerlink" title="碎片化"></a><strong>碎片化</strong></h5><p>使用TLAB的一个风险是，由于堆上内存碎片的增加，使用内存的效率会下降。如果应用程序创建的对象的大小无法填满TLAB，而这块TLAB中剩下的空间又太小，无法分配给新的对象，那么这块空间就被浪费了，这就是所谓的“碎片”。如果“碎片”周围已分配出去的内存长时间无法回收，那么这块碎片研究长时间无法得到利用。</p><p><code>碎片化</code>是指堆上存在了大量的<code>碎片</code>，由于这些小碎片的存在而使堆无法得到有效利用，浪费了堆空间。为应用程序设置TLAB的大小时，若是没有对应用程序中对象大小和生命周期和合理评估，导致TLAB的大小设置不当，就会是使堆逐渐碎片化。随着应用程序的运行，被浪费的碎片空间会逐渐增多，导致应用程序性能下降。这是因为系统无法为新线程和新对象分配空间，于是为防止出现OOM（out-of-memory）错误，而频繁GC的缘故。</p><p>对于TLAB产生的空间浪费这个问题，可以采用“曲线救国”的策略来解决。例如，可以根据应用程序的具体环境调整TLAB的大小。这个方法既可以临时，也可以彻底的避免堆空间的碎片化，但需要随着应用程序内存分配行为的变化而修改TLAB的值。此外，还可以使用一些复杂的JVM算法和其他的方法来组织堆空间来获得更有效率的内存分配行为。例如，JVM可以实现空闲列表（free-list），空闲列表中保存了堆中指定大小的空闲块。具有类似大小空闲块保存在一个空闲列表中，因此可以创建多个空闲列表，每个空闲列表保存某个范围内的空闲块。在某些事例中，使用空闲列表会比使用按实际大小分配内存的策略更有效率。线程为某个对象分配内存时，可以在空闲列表中寻找与对象大小最接近的空间块使用，相对于使用固定大小的TLAB，这种方法更有利于避免碎片化的出现。</p><h5 id="GC往事"><a href="#GC往事" class="headerlink" title="GC往事"></a><strong>GC往事</strong></h5><blockquote><p>早期的垃圾回收器有多个老年代，但实际上，存在多个老年代是弊大于利的。</p></blockquote><p>另一种对抗碎片化的方法是创建一个所谓的年轻代，在这个专有的堆空间中，保存了所有新创建的对象。堆空间中剩余的空间就是所谓的老年代。老年代用于保存具有较长生命周期的对象，即当对象能够挺过几轮GC而不被回收，或者对象本身很大（一般来说，大对象都具有较长的寿命周期）时，它们就会被保存到老年代。为了让你能够更好的理解这个方法，我们有必要谈谈垃圾回收。</p><h5 id="垃圾回收与应用程序性能"><a href="#垃圾回收与应用程序性能" class="headerlink" title="垃圾回收与应用程序性能"></a><strong>垃圾回收与应用程序性能</strong></h5><p>垃圾回收就是JVM释放那些没有引用指向的堆内存的操作。当垃圾回收首次触发时，有引用指向的对象会被保存下来，那些没有引用指向的对象占用的空间会被回收。当所有可回收的内存都被回收后，这些空间就可以被分配给新的对象了。</p><p>垃圾回收不会回收仍有引用指向的对象；否则就会违反JVM规范。这个规则有一个例外，就是对软引用或弱引用的使用，当垃圾回收器发现内存快要用完时，会回收只有软引用或<a href="http://java.sun.com/docs/books/performance/1st_edition/html/JPAppGC.fm.html" title="weak reference" target="_blank" rel="noopener">弱引用</a>指向的对象所占用的内存。我的建议是，尽量避免使用弱引用，因为Java规范中存在的模糊的表述可能会使你对弱引用的使用产生误解。此外，Java本身是动态内存管理的，你没必要考虑什么时候该释放哪块内存。</p><p>对于垃圾回收来说，挑战在于，如何将垃圾回收对应用程序造成的影响降到最小。如果垃圾回收执行的不充分，那么应用程序迟早会发生OOM错误；如果垃圾回收执行的太频繁，会对应用程序的吞吐量和响应时间造成影响，当然，这都不是好的影响。</p><h5 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a><strong>GC算法</strong></h5><p>目前已经出现了很多垃圾回收算法。在这个系列文章中将对其中的一些进行介绍。概括来说，垃圾回收主要有两种方式，引用计数（reference counting）和引用追踪（reference tracing）。</p><ul><li>引用计数垃圾回收器会记录指向某个对象的引用的数目。当指向某个对象引用数位0时，该对象占用的内存就可以被回收了，这是引用计数垃圾回收的一个主要优点。使用引用计数垃圾回收的需要克服的难点在于如何解决循环引用带来的问题，以及如何保证引用计数的实效性。</li><li>引用追踪垃圾回收器会标记所有仍有引用指向的对象，并从已标记的对象出发，继续标记这些对象指向的对象。当所有仍有引用指向的对象都被标记为“live”后，所有未标记的对象会被回收。这种方式可以解决循环引用结果带来的问题，但是大多数情况下，垃圾回收器必须等待标记完全结束才能开始进行垃圾回收。</li></ul><p>上面提到的两种算法有多种不同的实现方法，其中最著名可算是标记或拷贝算法（marking or copying algorithm）和并行或并发算法（parallel or concurrent algorithm）。我将在后续的文章中对它们进行介绍。</p><p>分代垃圾回收的意思是，将堆划分为几个不同的区域，分别用于存储新对象和老对象。其中“老对象”指的是挺过了几轮垃圾回收而不死的对象。将堆空间分为年轻代和老年代，分别用于存储新对象和老对象可以通过回收生命周期较短的对象，并将生命周期较长的对象从年轻代提升到老年代的方法来减少堆空间中的碎片，降低堆空间碎片化的风险。此外，使用年轻代还有一个好处是，它可以推出对老年代进行垃圾回收的需求（对老年代进行垃圾回收的代价比较大，因为老年代中那些生命周期较长的对象通常包含有更多的引用，遍历一次需要花费更多的时间），因那些生命周期较短的对通常会重用年轻代中的空间。</p><p>还有一个值得一提的算法改进是压缩，它可以用来管理堆空间中的碎片。基本上将，压缩就是将对象移动到一起，再释放掉较大的连续空间。如果你对磁盘碎片和处理磁盘碎片的工具比较熟悉的话你就会理解压缩的含义了，只不过这里的压缩是工作在Java堆空间中的。我将在该系列后续的内容中对压缩进行介绍。</p><h5 id="结论：回顾与展望"><a href="#结论：回顾与展望" class="headerlink" title="结论：回顾与展望"></a><strong>结论：回顾与展望</strong></h5><p>JVM实现了可移植性（“一次编写，到处运行”）和动态内存管理，这两个特点也是其广受欢迎，并且具有较高生产力的原因。</p><p>作为这个系列文章的第一篇，我介绍了编译器如何将字节码转换为平台相关指令的语言，以及如何<code>动态</code>优化Java程序的运行性能。不同的编译器迎合了不同应用程序的需要。</p><p>此外，简单介绍了内存分配和垃圾回收的一点内容，及其与Java应用程序性能的关系。基本上将，Java应用程序运行的速度越快，填满Java堆所需的时间就越短，触发垃圾回收的频率也越高。这里遇到的问题就是，在应用程序出现OOM错误之前，如何在对应用程序造成的影响尽可能小的情况下，回收足够多的内存空间。将后续的文章中，我们将对传统垃圾回收方法和现今的垃圾回收方法对JVM性能优化的影响做详细讨论。</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：Eva Andreasson,译者：曹旭东 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jdk1.7和1.8共存及切换</title>
      <link href="/2018/04/28/jdk1.7%E5%92%8C1.8%E5%85%B1%E5%AD%98%E5%8F%8A%E5%88%87%E6%8D%A2/"/>
      <url>/2018/04/28/jdk1.7%E5%92%8C1.8%E5%85%B1%E5%AD%98%E5%8F%8A%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a>所需软件</h3><p>jdk 1.7和1.8 64位</p><h3 id="安装步奏"><a href="#安装步奏" class="headerlink" title="安装步奏"></a>安装步奏</h3><p>1.7版本是普通的安装，但是1.8会在c盘创建几个文件，==以及修改注册表==。</p><h3 id="修改步奏"><a href="#修改步奏" class="headerlink" title="修改步奏"></a>修改步奏</h3><p>首先删掉1.8自动生成的环境变量，即：<br>C:\ProgramData\Oracle\Java\javapath;<br>并将此目录下的三个快捷方式删掉<br>然后删除1.8生成的几个文件 即 C:\Windows\System32下的java.exe，javaw.exe,javaws.exe<br>然后进入dos运行java -version<br>那么 ok  报错了   has value’1.8’，but ‘1.7’……<br><img src="http://i1.piimg.com/567571/ee8ac9f3c3023fc4.png" alt="">    </p><p>运行regedit打开注册表<strong>HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment</strong><br>点击它<br>然后点击右侧的CurrentVersion  将值1.8修改为1.7 然后确定<br>重新java -verison   成功</p><p><img src="http://i1.piimg.com/567571/aae8840adaf94c50.png" alt="">    </p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java操作Spark学习</title>
      <link href="/2018/04/28/Java%E6%93%8D%E4%BD%9CSpark%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/04/28/Java%E6%93%8D%E4%BD%9CSpark%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>[toc]</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://ns1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>io.file.buffer.size<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>131072<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yarn/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.journalnode.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yarn/journal<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.yarn.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>EPRI-DCLOUD-HDP01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.yarn.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">从hadoop/ect/hadoop里扒过来</span><br><span class="line">不需要最后一行配置</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.hosts.exclude<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yarn/hadoop-2.6.0/etc/hadoop/excludes<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">所需配置如下</span><br><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- Put site-specific property overrides in this file. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>ns1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.ns1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>nn0,nn1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns1.nn0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>EPRI-DCLOUD-HDP01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns1.nn0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>EPRI-DCLOUD-HDP01:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.ns1.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>EPRI-DCLOUD-HDP02:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address.ns1.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>EPRI-DCLOUD-HDP02:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.shared.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>qjournal://EPRI-DCLOUD-HDP01:8485;EPRI-DCLOUD-HDP02:8485;EPRI-DCLOUD-HDP03:8485/ns1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>EPRI-DCLOUD-HDP01,EPRI-DCLOUD-HDP02,EPRI-DCLOUD-HDP03<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>ha.zookeeper.session-timeout.ms<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>60000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.methods<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>sshfence<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.fencing.ssh.private-key-files<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yarn/.ssh/id_rsa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.automatic-failover.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.proxy.provider.ns1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yarn/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yarn/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.qjournal.write-txns.timeout.ms<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>600000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.webhdfs.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="hive-site-xml"><a href="#hive-site-xml" class="headerlink" title="hive-site.xml"></a>hive-site.xml</h4><pre><code>从hive的conf扒过来</code></pre><h3 id="所需jar文件"><a href="#所需jar文件" class="headerlink" title="所需jar文件"></a>所需jar文件</h3><pre><code>jar包从linux上扒下来</code></pre><h3 id="打jar方式"><a href="#打jar方式" class="headerlink" title="打jar方式"></a>打jar方式</h3><p><img src="http://i2.muimg.com/567571/2e8a84dbfbe2aae9.png" alt=""><br><img src="http://i4.buimg.com/567571/f134fd407fe7dd60.png" alt=""></p><h3 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h3><p>demo1：</p><pre><code class="java">SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"hivePartion"</span>);SparkContext sc = <span class="keyword">new</span> SparkContext(conf);HiveContext hiveCtx = <span class="keyword">new</span> HiveContext(sc);String sql = <span class="string">"select * from fjudm4.hbase_md_load_bus_hisdata limit 1"</span>;Row[] rows = hiveCtx.sql(sql).collect();<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows.length; i++) {    Row row = rows[i];    System.out.println(<span class="string">"i为"</span> + i + <span class="string">"    i对应的row为"</span> + row.toString());}    sc.stop();</code></pre><pre><code>#Row[] rows里装的是所有的查出来的数据  所有条   注意 它toString无法显示他的所有数据  只显示地址#row是一条数据  不是数组也不是list  格式:[20161103,115967690991992834,null,福建.半兰山/220kV.1负荷,null,ss,r,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,2016-11-04,2016-11-03]#row.get()类似于sql里的rs.getString();</code></pre><h2 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h2><p>phoenix-4.6.0-HBase-1.1-client.jar和spark-assembly-1.5.2-hadoop2.6.0.jar会冲突thrift包</p><pre><code class="java">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.metastore.HiveMetaStoreClientat org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:<span class="number">346</span>)at org.apache.spark.sql.hive.client.ClientWrapper.&lt;init&gt;(ClientWrapper.scala:<span class="number">171</span>)at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">57</span>)at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">526</span>)at org.apache.spark.sql.hive.client.IsolatedClientLoader.liftedTree1$<span class="number">1</span>(IsolatedClientLoader.scala:<span class="number">183</span>)at org.apache.spark.sql.hive.client.IsolatedClientLoader.&lt;init&gt;(IsolatedClientLoader.scala:<span class="number">179</span>)at org.apache.spark.sql.hive.HiveContext.metadataHive$lzycompute(HiveContext.scala:<span class="number">226</span>)at org.apache.spark.sql.hive.HiveContext.metadataHive(HiveContext.scala:<span class="number">185</span>)at org.apache.spark.sql.hive.HiveContext.setConf(HiveContext.scala:<span class="number">392</span>)at org.apache.spark.sql.hive.HiveContext.defaultOverrides(HiveContext.scala:<span class="number">174</span>)at org.apache.spark.sql.hive.HiveContext.&lt;init&gt;(HiveContext.scala:<span class="number">177</span>)at com.sgcc.epri.dcloud.dm_hive_datacheck.query.impl.HiveQueryImpl.queryCount(HiveQueryImpl.java:<span class="number">59</span>)at com.sgcc.epri.dcloud.dm_hive_datacheck.common.QueryAndCompare.doCheck(QueryAndCompare.java:<span class="number">48</span>)at com.sgcc.epri.dcloud.dm_hive_datacheck.common.Common.check(Common.java:<span class="number">35</span>)at com.sgcc.epri.dcloud.dm_hive_datacheck.main.MainCompare.main(MainCompare.java:<span class="number">18</span>)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">57</span>)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)at java.lang.reflect.Method.invoke(Method.java:<span class="number">606</span>)at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:<span class="number">674</span>)at org.apache.spark.deploy.SparkSubmit$.doRunMain$<span class="number">1</span>(SparkSubmit.scala:<span class="number">180</span>)at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:<span class="number">205</span>)at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:<span class="number">120</span>)at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)Caused by: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.metastore.HiveMetaStoreClient    at org.apache.hadoop.hive.metastore.MetaStoreUtils.newInstance(MetaStoreUtils.java:<span class="number">1412</span>)    at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.&lt;init&gt;(RetryingMetaStoreClient.java:<span class="number">62</span>)    at org.apache.hadoop.hive.metastore.RetryingMetaStoreClient.getProxy(RetryingMetaStoreClient.java:<span class="number">72</span>)    at org.apache.hadoop.hive.ql.metadata.Hive.createMetaStoreClient(Hive.java:<span class="number">2453</span>)    at org.apache.hadoop.hive.ql.metadata.Hive.getMSC(Hive.java:<span class="number">2465</span>)    at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:<span class="number">340</span>)    ... <span class="number">25</span> moreCaused by: java.lang.reflect.InvocationTargetException    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">57</span>)    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)    at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">526</span>)    at org.apache.hadoop.hive.metastore.MetaStoreUtils.newInstance(MetaStoreUtils.java:<span class="number">1410</span>)    ... <span class="number">30</span> moreCaused by: java.lang.NoSuchMethodError: org.apache.thrift.protocol.TProtocol.getScheme()Ljava/lang/Class;    at org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore$set_ugi_args.write(ThriftHiveMetastore.java)    at org.apache.thrift.TServiceClient.sendBase(TServiceClient.java:<span class="number">63</span>)    at org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore$Client.send_set_ugi(ThriftHiveMetastore.java:<span class="number">3260</span>)    at org.apache.hadoop.hive.metastore.api.ThriftHiveMetastore$Client.set_ugi(ThriftHiveMetastore.java:<span class="number">3251</span>)    at org.apache.hadoop.hive.metastore.HiveMetaStoreClient.open(HiveMetaStoreClient.java:<span class="number">352</span>)    at org.apache.hadoop.hive.metastore.HiveMetaStoreClient.&lt;init&gt;(HiveMetaStoreClient.java:<span class="number">214</span>)    ... <span class="number">35</span> more</code></pre><p>删除了phoenix包里的scheme包解决了</p><p>hiveSQL查询不出数据</p><pre><code class="sql"><span class="keyword">select</span> * <span class="keyword">from</span> fjudm4.HBASE_MD_MEASANALOG_BREAKER <span class="keyword">where</span> <span class="keyword">timestamp</span> &gt;= <span class="keyword">to_date</span>(<span class="string">'2016-11-01 00:00:00.0'</span>) <span class="keyword">and</span> <span class="keyword">timestamp</span> &lt; <span class="keyword">to_date</span>(<span class="string">'2016-11-01 00:05:00.0'</span>) <span class="keyword">limit</span> <span class="number">3</span>;</code></pre><p>sql错了，hive不可以用timestamp直接比较 应该用时间分区列date=’2016-11-01’</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/04/28/Exception/"/>
      <url>/2018/04/28/Exception/</url>
      <content type="html"><![CDATA[<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p>==author:YuanBo-Chi==</p><p>[toc]</p><h4 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.minor version 52.0"></a>Unsupported major.minor version 52.0</h4><p>Java虚拟机报错，jdk版本不匹配，右键项目properties</p><p><img src="https://ooo.0o0.ooo/2017/06/02/5930d955056f4.png" alt="1.png"></p><p><img src="https://ooo.0o0.ooo/2017/06/02/5930d9521ef64.png" alt="2.png"><br>当时jre7是灰色的，是不可用的，show all runtimes后选择jre8版本可以解决，或者等会再打开这个界面，会出现原来的版本jre7</p><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>今天出了个空指针的错，给String泛型的list添加(0+””)竟然给报错，经检查，是声明list的时候没有给它开辟空间，list添加0+””不会报错，会把0添加进去。</p><h4 id="连接服务器使用hive连接时FileNotFoundException"><a href="#连接服务器使用hive连接时FileNotFoundException" class="headerlink" title="连接服务器使用hive连接时FileNotFoundException"></a>连接服务器使用hive连接时FileNotFoundException</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">log4j:<span class="function">ERROR <span class="title">setFile</span><span class="params">(<span class="keyword">null</span>,<span class="keyword">true</span>)</span> call failed.</span></span><br><span class="line"><span class="function">java.io.FileNotFoundException: /home/yarn/hadoop-2.6.0/logs/flume-hadoop/flume-hadoop.<span class="title">log</span> <span class="params">(Permission denied)</span></span></span><br><span class="line"><span class="function">at java.io.FileOutputStream.<span class="title">open</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">at java.io.FileOutputStream.&lt;init&gt;<span class="params">(FileOutputStream.java:<span class="number">221</span>)</span></span></span><br><span class="line"><span class="function">at java.io.FileOutputStream.&lt;init&gt;<span class="params">(FileOutputStream.java:<span class="number">142</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.FileAppender.<span class="title">setFile</span><span class="params">(FileAppender.java:<span class="number">294</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.FileAppender.<span class="title">activateOptions</span><span class="params">(FileAppender.java:<span class="number">165</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.DailyRollingFileAppender.<span class="title">activateOptions</span><span class="params">(DailyRollingFileAppender.java:<span class="number">223</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.config.PropertySetter.<span class="title">activate</span><span class="params">(PropertySetter.java:<span class="number">307</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.config.PropertySetter.<span class="title">setProperties</span><span class="params">(PropertySetter.java:<span class="number">172</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.config.PropertySetter.<span class="title">setProperties</span><span class="params">(PropertySetter.java:<span class="number">104</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.PropertyConfigurator.<span class="title">parseAppender</span><span class="params">(PropertyConfigurator.java:<span class="number">842</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.PropertyConfigurator.<span class="title">parseCategory</span><span class="params">(PropertyConfigurator.java:<span class="number">768</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.PropertyConfigurator.<span class="title">configureRootCategory</span><span class="params">(PropertyConfigurator.java:<span class="number">648</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.PropertyConfigurator.<span class="title">doConfigure</span><span class="params">(PropertyConfigurator.java:<span class="number">514</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.PropertyConfigurator.<span class="title">doConfigure</span><span class="params">(PropertyConfigurator.java:<span class="number">580</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.helpers.OptionConverter.<span class="title">selectAndConfigure</span><span class="params">(OptionConverter.java:<span class="number">526</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.log4j.LogManager.&lt;clinit&gt;<span class="params">(LogManager.java:<span class="number">127</span>)</span></span></span><br><span class="line"><span class="function">at org.slf4j.impl.Log4jLoggerFactory.<span class="title">getLogger</span><span class="params">(Log4jLoggerFactory.java:<span class="number">66</span>)</span></span></span><br><span class="line"><span class="function">at org.slf4j.LoggerFactory.<span class="title">getLogger</span><span class="params">(LoggerFactory.java:<span class="number">270</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.commons.logging.impl.SLF4JLogFactory.<span class="title">getInstance</span><span class="params">(SLF4JLogFactory.java:<span class="number">155</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.commons.logging.impl.SLF4JLogFactory.<span class="title">getInstance</span><span class="params">(SLF4JLogFactory.java:<span class="number">132</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.commons.logging.LogFactory.<span class="title">getLog</span><span class="params">(LogFactory.java:<span class="number">657</span>)</span></span></span><br><span class="line"><span class="function">at org.apache.hadoop.util.VersionInfo.&lt;clinit&gt;<span class="params">(VersionInfo.java:<span class="number">37</span>)</span></span></span><br><span class="line"><span class="function">log4j:ERROR Either File or DatePattern options are not set <span class="keyword">for</span> appender [File].</span></span><br><span class="line"><span class="function">SLF4J: Class path contains multiple SLF4J bindings.</span></span><br><span class="line"><span class="function">SLF4J: Found binding in [jar:file:/home/yarn/hadoop-2.6.0/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span></span><br></pre></td></tr></table></figure><p>这个是因为使用的用户的权限不够<br>noClassFound一般是jar包依赖</p><h4 id="Java操作phoenix连接需要配置host文件"><a href="#Java操作phoenix连接需要配置host文件" class="headerlink" title="Java操作phoenix连接需要配置host文件"></a>Java操作phoenix连接需要配置host文件</h4><p>url：C:\Windows\System32\drivers\etc</p><p>连接hivejdbc的时候一个报错</p><p><img src="https://ooo.0o0.ooo/2017/06/02/5930d9545532a.png" alt="3.png"><br>一番查找之后发现是phoenix-4.6.0-HBase-1.1-client.jar导致的</p><h4 id="fat-jar打包"><a href="#fat-jar打包" class="headerlink" title="fat-jar打包"></a>fat-jar打包</h4><p>用fat-jar打成jar包放在服务器上运行，有可能会丢失依赖的jar包导致程序运行出错，或者不报错却查不出数据，使用eclipse本身自带的打jar工具，右键export,选择Java里的runnable JAR file</p><p><img src="https://ooo.0o0.ooo/2017/06/02/5930d954e38e8.png" alt="4.png"><br>改变项目路径的时候，需要把新的路径–build path–use as source folder<br>build的路径会成为固定路径 比如com.baidu.demo<br>如果只有com包就build，.java的package为baidu.demo</p><p>上传maven项目时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dmaven.multiModuleProjectDirectory system property is not set. Check $M2_HOME environment variable and mvn script match.</span><br><span class="line">.添加M2_HOME的环境变量</span><br><span class="line"><span class="number">2</span>.Preference-&gt;Java-&gt;Installed JREs-&gt;Edit 选择一个jdk,</span><br><span class="line">添加  -Dmaven.multiModuleProjectDirectory=$M2_HOME</span><br><span class="line"></span><br><span class="line">-Dmaven.multiModuleProjectDirectory=$M2_HOME</span><br></pre></td></tr></table></figure><p><img src="https://ooo.0o0.ooo/2017/06/02/5930d954e56fb.png" alt="5.png"></p><h4 id="执行hive查询时-Error-while-processing-statement-FAILED-Execution-Error-return-code-1-from-org-apache-hadoop-hive-ql-exec-mr-MapRedTask"><a href="#执行hive查询时-Error-while-processing-statement-FAILED-Execution-Error-return-code-1-from-org-apache-hadoop-hive-ql-exec-mr-MapRedTask" class="headerlink" title="执行hive查询时 Error while processing statement: FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask"></a>执行hive查询时 Error while processing statement: FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLException: Error <span class="keyword">while</span> processing statement: FAILED: Execution Error, <span class="keyword">return</span> code <span class="number">1</span> from org.apache.hadoop.hive.ql.exec.mr.MapRedTask</span><br><span class="line">at org.apache.hive.jdbc.HiveStatement.execute(HiveStatement.java:<span class="number">296</span>)</span><br><span class="line">at org.apache.hive.jdbc.HiveStatement.executeQuery(HiveStatement.java:<span class="number">392</span>)</span><br><span class="line">at org.apache.hive.jdbc.HivePreparedStatement.executeQuery(HivePreparedStatement.java:<span class="number">109</span>)</span><br><span class="line">at com.sgcc.epri.dcloud.dm_hive_datacheck.query.HiveQuery.queryHiveLoadCount(HiveQuery.java:<span class="number">39</span>)</span><br><span class="line">at com.sgcc.epri.dcloud.dm_hive_datacheck.common.ReadExcelAndCompare.readLoad(ReadExcelAndCompare.java:<span class="number">90</span>)</span><br><span class="line">at com.sgcc.epri.dcloud.dm_hive_datacheck.main.MainLoad_Forecast.main(MainLoad_Forecast.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><img src="https://ooo.0o0.ooo/2017/06/02/5930d954287b9.png" alt="6.png"><br>这是hdfs没有空间了</p><h4 id="hive查询聚合函数-找不到COUNT这个列"><a href="#hive查询聚合函数-找不到COUNT这个列" class="headerlink" title="hive查询聚合函数 找不到COUNT这个列"></a>hive查询聚合函数 找不到COUNT这个列</h4><p>使用count = rs.getString(1);来取 不要用count = rs.getString(“COUNT”);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">select <span class="title">count</span><span class="params">(<span class="number">1</span>)</span> as COUNT from fjudm4.hbase_md_load_bus_fc_96lc_submit_balance where date </span>= <span class="string">'2016-01-01'</span></span><br><span class="line">java.sql.SQLException</span><br><span class="line">at org.apache.hadoop.hive.jdbc.HiveBaseResultSet.findColumn(HiveBaseResultSet.java:<span class="number">81</span>)</span><br><span class="line">at org.apache.hadoop.hive.jdbc.HiveBaseResultSet.getString(HiveBaseResultSet.java:<span class="number">484</span>)</span><br><span class="line">at com.sgcc.epri.dcloud.dm_hive_datacheck.query.HiveQuery.queryHiveLoadCount(HiveQuery.java:<span class="number">47</span>)</span><br><span class="line">at com.sgcc.epri.dcloud.dm_hive_datacheck.common.ReadExcelAndCompare.readLoad(ReadExcelAndCompare.java:<span class="number">120</span>)</span><br><span class="line">at com.sgcc.epri.dcloud.dm_hive_datacheck.main.MainLoad_ForecastCount.main(MainLoad_ForecastCount.java:<span class="number">16</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">57</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">606</span>)</span><br><span class="line">at org.eclipse.jdt.internal.jarinjarloader.JarRsrcLoader.main(JarRsrcLoader.java:<span class="number">58</span>)</span><br></pre></td></tr></table></figure><h4 id="maven配置ojdbc"><a href="#maven配置ojdbc" class="headerlink" title="maven配置ojdbc"></a>maven配置ojdbc</h4><p>因为ojdbc是收费的！(/哭)只能自己下载ojdbc对应的版本jar包，在当前路径打开dos，比如我是在桌面，我执行命令将它安装到本地仓库</p><pre><code>mvn install:install-file -DgroupId=com.Oracle -DartifactId=ojdbc14 -Dversion=10.2.0.2.0 -Dpackaging=jar -Dfile=C:\Users\Administrator\Desktop\ojdbc14-10.2.0.2.0.jar</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Elasticsearch-Head插件</title>
      <link href="/2018/04/28/Elasticsearch-Head%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/04/28/Elasticsearch-Head%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>[toc]</p><p>Apache Lucene将所有信息写到一个成为倒排索引的结构中。</p><h3 id="ES与MYSQL对应关系"><a href="#ES与MYSQL对应关系" class="headerlink" title="ES与MYSQL对应关系"></a>ES与MYSQL对应关系</h3><p><img src="https://ooo.0o0.ooo/2017/06/08/5938e8d6b2bcf.png" alt="20160717132008382.png"></p><p>以上表为依据，<br>ES中的新建文档（在Index/type下）相当于Mysql中（在某Database的Table）下插入一行数据。</p><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p><img src="https://ooo.0o0.ooo/2017/06/08/5938ea18205aa.png" alt="20160717132135758.png"></p><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>查询全部文档如下： </p><p><img src="https://ooo.0o0.ooo/2017/06/08/5938ea1842289.png" alt="20160717132224477.png"></p><p>复合查询 </p><p><img src="https://ooo.0o0.ooo/2017/06/08/5938eba553d23.png" alt="微信截图_20170608141549.png"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><img src="https://ooo.0o0.ooo/2017/06/08/5938edfc39280.png" alt="微信截图_20170608142552.png"></p><p><img src="https://ooo.0o0.ooo/2017/06/08/5938edcef011c.png" alt="1496903100(1.png"></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="https://ooo.0o0.ooo/2017/06/08/5938ee2917fe9.png" alt="12312.png"></p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AtomicInteger</title>
      <link href="/2018/04/28/AtomicInteger/"/>
      <url>/2018/04/28/AtomicInteger/</url>
      <content type="html"><![CDATA[<p>AtomicInteger 是一个支持原子操作的 Integer 类，就是保证对AtomicInteger类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。通常情况下，在Java里面，++i或者–i不是线程安全的，这里面有三个独立的操作：获取变量当前值，为该值+1/-1，然后写回新的值。在没有额外资源可以利用的情况下，只能使用加锁才能保证读-改-写这三个操作时“原子性”的。</p><p>先看AtomicInteger中的几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span></span></span><br><span class="line"><span class="function"> 以原子方式将给定值与当前值相加。实际上就是等于线程安全版本的i</span>=i+delta操作。</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span></span><br><span class="line"><span class="function"> 如果当前值 </span>==预期值，则以原子方式将该值设置为给定的更新值。如果成功就返回<span class="keyword">true</span>，否则返  回<span class="keyword">false</span>，并且不修改原值。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  以原子方式将当前值减 1。相当于线程安全版本的--i操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  获取当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(intdelta)</span></span></span><br><span class="line"><span class="function"> 以原子方式将给定值与当前值相加。相当于线程安全版本的t</span>=i;i+=delta;returnt;操作。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 以原子方式将当前值减 1。相当于线程安全版本的i--操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 以原子方式将当前值加 1。相当于线程安全版本的i++操作。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(intnewValue)</span></span></span><br><span class="line"><span class="function"> 以原子方式设置为给定值，并返回旧值。相当于线程安全版本的t</span>=i;i=newValue;returnt;操作。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  以原子方式将当前值加 1。相当于线程安全版本的++i操作。</span></span><br></pre></td></tr></table></figure><p>再看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">valueOffset = unsafe.objectFieldOffset  </span><br><span class="line">(AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));  </span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;  </span><br><span class="line">value = initialValue;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;  </span><br><span class="line">value = newValue;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;  </span><br><span class="line">unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//以原子方式设置为给定值，并返回旧值。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, newValue))  </span><br><span class="line"><span class="keyword">return</span> current;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果当前值 ==预期值，则以原子方式将该值设置为给定的更新值。如果成功就返回，否则返回，并且不修改原值。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式将当前值加1。相当于线程安全版本的i++操作。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> current;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//以原子方式将当前值减 1相当于线程安全版本的i--操作。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current - <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> current;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式将给定值与当前值相加。相当于线程安全版本的操作。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current + delta;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> current;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//以原子方式将当前值加 1相当于线程安全版本的++i操作。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> next;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//以原子方式将当前值减 1。相当于线程安全版本的--i操作。  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current - <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> next;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//以原子方式将给定值与当前值相加。实际上就是等于线程安全版本的i=i+delta操作  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current + delta;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> next;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以发现，AtomicInteger并没有使用Synchronized关键字实现原子性，几乎所有的数据更新都用到了compareAndSet(int expect, int update)这个方法。那么就不难看出AtomicInteger这个类的最核心的函数就是compareAndSet(int expect, int update)。</p><p>那么compareAndSet(int expect, int update)是干什么的呢？？？？</p><p>我们以getAndIncrement()方法为例，它的源码如下：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;  </span><br><span class="line"><span class="keyword">int</span> current = get();  </span><br><span class="line"><span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line"><span class="keyword">return</span> current;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==单看这段 代码 很难保证原子性， 因为根本没有更新value 的操作==</p><p> 重点在于compareAndSet() 函数</p><pre><code>public final boolean compareAndSet(int expect,int update)</code></pre><p>如果==当前值== == ==预期值==，则以原子方式将== 当前值 设置为给定的更新值。==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">expect - 预期值</span><br><span class="line">update - 新值</span><br><span class="line">返回：</span><br><span class="line">如果成功，则返回 <span class="keyword">true</span>。返回 False 指示实际值与预期值不相等。</span><br></pre></td></tr></table></figure><p>该函数 只有两个参数，可操作的确实三个值 ，即 value ,expect, update. 他使用了 由硬件保证其原子性的指令 CAS （compare and swap）。</p><p>compareAndSet  函数保证了 比较，赋值这两步操作可以通过一个原子操作完成。</p><p>然后看整个函数， 所有代码被放到了一个循环里面， </p><p>如果compareAndSet（）执行失败，则说明 在int current = get(); 后，其他线程对value进行了更新， 于是就循环一次，重新获取当前值，直到compareAndSet（）执行成功为止。<br>这里需要注意的是AtomicInteger所利用的是基于冲突检测的乐观并发策略（CAS自旋锁）。 所以这种乐观在线程数目非常多的情况下，失败的概率会指数型增加。</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《JAVA与模式》之单例模式</title>
      <link href="/2018/04/28/%E3%80%8AJAVA%E4%B8%8E%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/04/28/%E3%80%8AJAVA%E4%B8%8E%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>[toc]</p><p>在阎宏博士的《JAVA与模式》一书中开头是这样描述单例模式的：</p><p>　　==作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。==</p><h3 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h3><p>==单例模式的特点：==</p><pre><code>单例类只能有一个实例。单例类必须自己创建自己的唯一实例。单例类必须给所有其他对象提供这一实例。</code></pre><h4 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有默认构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上面的例子中，在这个类被加载时，静态变量instance会被初始化，此时类的私有构造子会被调用。这时候，单例类的唯一实例就被创建出来了。</p><p>　　饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p><pre><code>private static EagerSingleton instance = new EagerSingleton();</code></pre><p>　　饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。</p><h4 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类"></a>懒汉式单例类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有默认构造子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。　　</p><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。</p><pre><code>private static LazySingleton instance = null;</code></pre><p>懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间</p><p>由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？</p><h4 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h4><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？</p><p>所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p><p>　　“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p><p>　　注意：在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。</p><p>　　==提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。==</p><p>　　根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？</p><h4 id="Lazy-initialization-holder-class模式"><a href="#Lazy-initialization-holder-class模式" class="headerlink" title="Lazy initialization holder class模式"></a>Lazy initialization holder class模式</h4><p>　　这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。</p><h5 id="1-相应的基础知识"><a href="#1-相应的基础知识" class="headerlink" title="1.相应的基础知识"></a>1.相应的基础知识</h5><p>　什么是类级内部类？<br>　　简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。</p><p>　　类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。</p><p>　　类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。</p><p>　　类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。</p><p>　多线程缺省同步锁的知识<br>　　大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：</p><pre><code>1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时2.访问final字段时3.在创建线程之前创建对象时4.线程可以看见它将要处理的对象时</code></pre><h5 id="2-解决方案的思路"><a href="#2-解决方案的思路" class="headerlink" title="2.解决方案的思路"></a>2.解决方案的思路</h5><p>　　要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。</p><p>　　如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。</p><p>　　示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span></span><br><span class="line"><span class="comment">     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p><p>　　这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p><p>　　</p><p>　　单例和枚举</p><p>　　按照《高效Java 第二版》中的说法：单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    uniqueInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例可以有自己的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//功能处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>]]></content>
      
      
        <tags>
            
            <tag> 作者：YuanBo-Chi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/04/28/%E3%80%8AJAVA%E4%B8%8E%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/04/28/%E3%80%8AJAVA%E4%B8%8E%E6%A8%A1%E5%BC%8F%E3%80%8B%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="《JAVA与模式》之抽象工厂模式"><a href="#《JAVA与模式》之抽象工厂模式" class="headerlink" title="《JAVA与模式》之抽象工厂模式"></a>《JAVA与模式》之抽象工厂模式</h2><p>==author:YuanBo-Chi==</p><p>场景问题<br>　　举个生活中常见的例子——组装电脑，我们在组装电脑的时候，通常需要选择一系列的配件，比如CPU、硬盘、内存、主板、电源、机箱等。为讨论使用简单点，只考虑选择CPU和主板的问题。</p><p>　　事实上，在选择CPU的时候，面临一系列的问题，比如品牌、型号、针脚数目、主频等问题，只有把这些问题都确定下来，才能确定具体的CPU。</p><p>　　同样，在选择主板的时候，也有一系列问题，比如品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。</p><p>　　选择不同的CPU和主板，是每个客户在组装电脑的时候，向装机公司提出的要求，也就是我们每个人自己拟定的装机方案。</p><p>　　在最终确定这个装机方案之前，还需要整体考虑各个配件之间的兼容性。比如：CPU和主板，如果使用Intel的CPU和AMD的主板是根本无法组装的。因为Intel的CPU针脚数与AMD主板提供的CPU插口不兼容，就是说如果使用Intel的CPU根本就插不到AMD的主板中，所以装机方案是整体性的，里面选择的各个配件之间是有关联的。</p><p>　　对于装机工程师而言，他只知道组装一台电脑，需要相应的配件，但是具体使用什么样的配件，还得由客户说了算。也就是说装机工程师只是负责组装，而客户负责选择装配所需要的具体的配件。因此，当装机工程师为不同的客户组装电脑时，只需要根据客户的装机方案，去获取相应的配件，然后组装即可。</p><p>使用简单工厂模式的解决方案<br>　　考虑客户的功能，需要选择自己需要的CPU和主板，然后告诉装机工程师自己的选择，接下来就等着装机工程师组装电脑了。</p><p>　　对装机工程师而言，只是知道CPU和主板的接口，而不知道具体实现，很明显可以用上简单工厂模式或工厂方法模式。为了简单，这里选用简单工厂。客户告诉装机工程师自己的选择，然后装机工程师会通过相应的工厂去获取相应的实例对象。</p><p>　　<img src="http://i4.buimg.com/567571/13263f85752d09fe.png" alt=""></p><p>源代码<br>CPU接口与具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelCpu</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU的针脚数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pins = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">IntelCpu</span><span class="params">(<span class="keyword">int</span> pins)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pins = pins;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Intel CPU的针脚数："</span> + pins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdCpu</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU的针脚数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pins = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">AmdCpu</span><span class="params">(<span class="keyword">int</span> pins)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pins = pins;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AMD CPU的针脚数："</span> + pins);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主板接口与具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mainboard</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelMainboard</span> <span class="keyword">implements</span> <span class="title">Mainboard</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU插槽的孔数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cpuHoles = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法，传入CPU插槽的孔数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cpuHoles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IntelMainboard</span><span class="params">(<span class="keyword">int</span> cpuHoles)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.cpuHoles = cpuHoles;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Intel主板的CPU插槽孔数是："</span> + cpuHoles);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdMainboard</span> <span class="keyword">implements</span> <span class="title">Mainboard</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU插槽的孔数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cpuHoles = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法，传入CPU插槽的孔数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cpuHoles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AmdMainboard</span><span class="params">(<span class="keyword">int</span> cpuHoles)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.cpuHoles = cpuHoles;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AMD主板的CPU插槽孔数是："</span> + cpuHoles);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPU与主板工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CpuFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cpu <span class="title">createCpu</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        Cpu cpu = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">            cpu = <span class="keyword">new</span> IntelCpu(<span class="number">755</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</span><br><span class="line">            cpu = <span class="keyword">new</span> AmdCpu(<span class="number">938</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainboardFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mainboard <span class="title">createMainboard</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        Mainboard mainboard = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">            mainboard = <span class="keyword">new</span> IntelMainboard(<span class="number">755</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</span><br><span class="line">            mainboard = <span class="keyword">new</span> AmdMainboard(<span class="number">938</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装机工程师类与客户类运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerEngineer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义组装机需要的CPU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Cpu cpu = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义组装机需要的主板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Mainboard mainboard = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">(<span class="keyword">int</span> cpuType , <span class="keyword">int</span> mainboard)</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装机器的基本步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1:首先准备好装机所需要的配件</span></span><br><span class="line">prepareHardwares(cpuType, mainboard);</span><br><span class="line"><span class="comment">//2:组装机器</span></span><br><span class="line"><span class="comment">//3:测试机器</span></span><br><span class="line"><span class="comment">//4：交付客户</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareHardwares</span><span class="params">(<span class="keyword">int</span> cpuType , <span class="keyword">int</span> mainboard)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></span><br><span class="line"><span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接找相应的工厂获取</span></span><br><span class="line"><span class="keyword">this</span>.cpu = CpuFactory.createCpu(cpuType);</span><br><span class="line"><span class="keyword">this</span>.mainboard = MainboardFactory.createMainboard(mainboard);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试配件是否好用</span></span><br><span class="line"><span class="keyword">this</span>.cpu.calculate();</span><br><span class="line"><span class="keyword">this</span>.mainboard.installCPU();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">ComputerEngineer cf = <span class="keyword">new</span> ComputerEngineer();</span><br><span class="line">cf.makeComputer(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://i1.piimg.com/567571/f9a2a9561ec8f784.png" alt=""></p><p>　　上面的实现，虽然通过简单工厂方法解决了：对于装机工程师，只知CPU和主板的接口，而不知道具体实现的问题。但还有一个问题没有解决，那就是这些CPU对象和主板对象其实是有关系的，需要相互匹配的。而上面的实现中，并没有维护这种关联关系，CPU和主板是由客户任意选择，这是有问题的。比如在客户端调用makeComputer时，传入参数为(1,2)，运行结果如下：<br>　　<br><img src="http://i1.piimg.com/567571/d97478321e7484a6.png" alt="">　　</p><p>观察上面结果就会看出问题。客户选择的是Intel的CPU针脚数为755，而选择的主板是AMD，主板上的CPU插孔是938，根本无法组装，这就是没有维护配件之间的关系造成的。该怎么解决这个问题呢？　　</p><p>引进抽象工厂模式<br>　　每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。</p><p>　　在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。</p><p>　　所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下：</p><p><img src="http://i2.muimg.com/567571/47cee263d5875255.png" alt=""></p><p>　　显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。</p><p>　　上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图：</p><p><img src="http://i4.buimg.com/567571/6e7162e054a969a0.png" alt=""></p><p>　　　　那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。</p><p><img src="http://i1.piimg.com/567571/55f2e61a34570201.png" alt=""></p><p>　　可以看出，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。显然，这时候抽象工厂模式比简单工厂模式、工厂方法模式更有效率。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。</p><p>抽象工厂模式结构<br>　　抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广。</p><p>　　假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。</p><p>　　通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。如下图所示：</p><p><img src="http://i1.piimg.com/567571/f84184086ae65990.png" alt=""></p><p>　　由于这两个产品族的等级结构相同，因此使用同一个工厂族也可以处理这两个产品族的创建问题，这就是抽象工厂模式。</p><p>　　根据产品角色的结构图，就不难给出工厂角色的结构设计图。</p><p><img src="http://i2.muimg.com/567571/2a32b8ef3b9079cb.png" alt=""></p><p>　　可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属不同产品等级结构的产品对象。</p><p>　<img src="http://i1.piimg.com/567571/096ff2758e8e0459.png" alt="">　</p><p>源代码<br>　　前面示例实现的CPU接口和CPU实现对象，主板接口和主板实现对象，都不需要变化。</p><p>　　前面示例中创建CPU的简单工厂和创建主板的简单工厂，都不再需要。</p><p>　　新加入的抽象工厂类和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建CPU对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> CPU对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建主板对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 主板对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mainboard <span class="title">createMainboard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IntelCpu(<span class="number">755</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mainboard <span class="title">createMainboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IntelMainboard(<span class="number">755</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IntelCpu(<span class="number">938</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mainboard <span class="title">createMainboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IntelMainboard(<span class="number">938</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　装机工程师类跟前面的实现相比，主要的变化是：从客户端不再传入选择CPU和主板的参数，而是直接传入客户已经选择好的产品对象。这样就避免了单独去选择CPU和主板所带来的兼容性问题，客户要选就是一套，就是一个系列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerEngineer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义组装机需要的CPU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Cpu cpu = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义组装机需要的主板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Mainboard mainboard = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">(AbstractFactory af)</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装机器的基本步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1:首先准备好装机所需要的配件</span></span><br><span class="line">prepareHardwares(af);</span><br><span class="line"><span class="comment">//2:组装机器</span></span><br><span class="line"><span class="comment">//3:测试机器</span></span><br><span class="line"><span class="comment">//4：交付客户</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareHardwares</span><span class="params">(AbstractFactory af)</span></span>&#123;</span><br><span class="line"><span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></span><br><span class="line"><span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接找相应的工厂获取</span></span><br><span class="line"><span class="keyword">this</span>.cpu = af.createCpu();</span><br><span class="line"><span class="keyword">this</span>.mainboard = af.createMainboard();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试配件是否好用</span></span><br><span class="line"><span class="keyword">this</span>.cpu.calculate();</span><br><span class="line"><span class="keyword">this</span>.mainboard.installCPU();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建装机工程师对象</span></span><br><span class="line">ComputerEngineer cf = <span class="keyword">new</span> ComputerEngineer();</span><br><span class="line"><span class="comment">//客户选择并创建需要使用的产品对象</span></span><br><span class="line">AbstractFactory af = <span class="keyword">new</span> IntelFactory();</span><br><span class="line"><span class="comment">//告诉装机工程师自己选择的产品，让装机工程师组装电脑</span></span><br><span class="line">cf.makeComputer(af);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和CPU，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。<br>　　<br><img src="http://i4.buimg.com/567571/a0c4dd730e72959c.png" alt=""></p><p>　　由于抽象工厂定义的一系列对象通常是相关或相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。</p><p>　　这就带来非常大的灵活性，切换产品族的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以一个产品族作为一个整体被切换。</p><p><img src="http://i4.buimg.com/567571/e2b124ee31a1f5af.png" alt="">　　</p><p>在什么情况下应当使用抽象工厂模式<br>　　1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。</p><p>　　2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p>　　3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组）</p><p>　　4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</p><p>抽象工厂模式的起源<br>　　抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。</p><p>　　在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。</p><p><img src="http://i1.piimg.com/567571/84865c898668e400.png" alt=""><br>　　<br>　　可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。</p><p><img src="http://i1.piimg.com/567571/ddbb2cfb987cdb88.png" alt=""></p><p>　　系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图：</p><p><img src="http://i4.buimg.com/567571/9f918c862785449c.png" alt="">　　</p><p>　　显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。</p><p>　　在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。因此，可以不必理会前面所提到的原始用意。</p><p>抽象工厂模式的优点<br>分离接口和实现<br>　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。</p><p>使切换产品族变得容易<br>　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。</p><p>抽象工厂模式的缺点<br>不太容易扩展新的产品<br>　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/28/hello-world/"/>
      <url>/2018/04/28/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
