<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="YB-Chi,undefined"><meta name="copyright" content="YB-Chi"><title> | YB-Chi</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">YB-Chi</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">21</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a></div></div></div><nav class="http://osapnihnq.bkt.clouddn.com/blog/180428/0GDEA8hFH0.jpg?imageslim" id="nav" style="background-image: url(http://osapnihnq.bkt.clouddn.com/blog/180428/0GDEA8hFH0.jpg?imageslim)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">YB-Chi</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">YB-Chi</div><div id="site-sub-title"></div><div id="site-social-icons"> <a class="social-icon" href="https://github.com/chiyuanbo" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="http://weibo.com/3189085434" target="_blank"><i class="fa fa-weibo"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local Search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><hr class="local-search-stats__hr">Powered by <span style="color: #49B1F5">hexo-generator-search</span></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item"><a class="article-title" href="/2018/04/28/深入剖析volatile关键字/">深入剖析volatile关键字</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><ul>
<li><a href="#一内存模型的相关概念">一.内存模型的相关概念</a></li>
<li><a href="#二并发编程中的三个概念">二.并发编程中的三个概念</a><ul>
<li><a href="#1原子性">1.原子性</a></li>
<li><a href="#2可见性">2.可见性</a></li>
<li><a href="#3有序性">3.有序性</a></li>
</ul>
</li>
<li><a href="#三java内存模型">三.Java内存模型</a><ul>
<li><a href="#1原子性">1.原子性</a></li>
<li><a href="#2可见性">2.可见性</a></li>
<li><a href="#3有序性">3.有序性</a></li>
</ul>
</li>
<li><a href="#四深入剖析volatile关键字">四.深入剖析volatile关键字</a><ul>
<li><a href="#1volatile关键字的两层语义">1.volatile关键字的两层语义</a></li>
<li><a href="#2volatile保证原子性吗">2.volatile保证原子性吗？</a></li>
<li><a href="#3volatile能保证有序性吗">3.volatile能保证有序性吗？</a></li>
</ul>
</li>
<li><a href="#五使用volatile关键字的场景">五.使用volatile关键字的场景</a><ul>
<li><a href="#1状态标记量">1.状态标记量</a></li>
<li><a href="#2double-check">2.double check</a></li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>&emsp;&emsp;volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<h3 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h3><p>&emsp;&emsp;大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>&emsp;&emsp;也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<pre><code>i = i + 1;  
</code></pre><p>&emsp;&emsp;当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>&emsp;&emsp;这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>&emsp;&emsp;比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>&emsp;&emsp;可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>&emsp;&emsp;最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>　　<br>&emsp;&emsp;也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>&emsp;&emsp;为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<p>&emsp;&emsp;1）通过在总线加LOCK#锁的方式</p>
<p>&emsp;&emsp;2）通过缓存一致性协议</p>
<p>&emsp;&emsp;这2种方式都是硬件层面上提供的方式。</p>
<p>&emsp;&emsp;在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>&emsp;&emsp;但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>&emsp;&emsp;所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。<br><img src="http://i1.piimg.com/567571/2c8fdb86b1860315.jpg" alt=""></p>
<h3 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h3><pre><code>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：
</code></pre><h4 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h4><p>&emsp;&emsp;原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>&emsp;&emsp;一个很经典的例子就是银行账户转账问题：</p>
<p>&emsp;&emsp;比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>&emsp;&emsp;试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>&emsp;&emsp;所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>&emsp;&emsp;同样地反映到并发编程中会出现什么结果呢？</p>
<p>&emsp;&emsp;举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<pre><code>i = 9;  
</code></pre><p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。           </p>
<h4 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码  </span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">i = <span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码  </span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>&emsp;&emsp;此时线程2执行 j =i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>&emsp;&emsp;这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h4 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>&emsp;&emsp;有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;                </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1    </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>&emsp;&emsp;下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>&emsp;&emsp;比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>&emsp;&emsp;但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1  </span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2  </span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3  </span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p><img src="http://i2.muimg.com/567571/57f70712db840e39.jpg" alt=""><br>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>&emsp;&emsp;不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>&emsp;&emsp;虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:  </span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1  </span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:  </span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;  </span><br><span class="line">  sleep()  </span><br><span class="line">&#125;  </span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>&emsp;&emsp;从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>&emsp;&emsp;也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h3 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h3><p>&emsp;&emsp;在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>&emsp;&emsp;在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>&emsp;&emsp;Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>&emsp;&emsp;举个简单的例子：在java中，执行下面这个语句：</p>
<pre><code>i  = 10;  
</code></pre><p>&emsp;&emsp;执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>&emsp;&emsp;那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h4 id="1-原子性-1"><a href="#1-原子性-1" class="headerlink" title="1.原子性"></a>1.原子性</h4><p>&emsp;&emsp;在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>&emsp;&emsp;上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：<br>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1  </span></span><br><span class="line">y = x;         <span class="comment">//语句2  </span></span><br><span class="line">x++;           <span class="comment">//语句3  </span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>&emsp;&emsp;语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>&emsp;&emsp;语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>&emsp;&emsp;同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>&emsp;&emsp;所以上面4个语句只有语句1的操作具备原子性。</p>
<p>&emsp;&emsp;也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>&emsp;&emsp;不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>&emsp;&emsp;从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h4 id="2-可见性-1"><a href="#2-可见性-1" class="headerlink" title="2.可见性"></a>2.可见性</h4><p>&emsp;&emsp;对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>&emsp;&emsp;当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>&emsp;&emsp;而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>&emsp;&emsp;另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h4 id="3-有序性-1"><a href="#3-有序性-1" class="headerlink" title="3.有序性"></a>3.有序性</h4><p>&emsp;&emsp;在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>&emsp;&emsp;在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>&emsp;&emsp;另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>&emsp;&emsp;下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<ul>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;这8条原则摘自《深入理解Java虚拟机》。</p>
<p>&emsp;&emsp;这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>&emsp;&emsp;下面我们来解释一下前4条规则：</p>
<p>&emsp;&emsp;对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>&emsp;&emsp;第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>&emsp;&emsp;第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>&emsp;&emsp;第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h3 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h3><p>&emsp;&emsp;在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<h4 id="1-volatile关键字的两层语义"><a href="#1-volatile关键字的两层语义" class="headerlink" title="1.volatile关键字的两层语义"></a>1.volatile关键字的两层语义</h4><p>&emsp;&emsp;一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<pre><code>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
</code></pre><p>&emsp;&emsp;先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1  </span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;  </span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;  </span><br><span class="line">	doSomething();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2  </span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>&emsp;&emsp;下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>&emsp;&emsp;那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>&emsp;&emsp;但是用volatile修饰之后就变得不一样了：</p>
<p>&emsp;&emsp;第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>&emsp;&emsp;第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>&emsp;&emsp;第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>&emsp;&emsp;那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>&emsp;&emsp;那么线程1读取到的就是最新的正确的值。</p>
<h4 id="2-volatile保证原子性吗？"><a href="#2-volatile保证原子性吗？" class="headerlink" title="2.volatile保证原子性吗？"></a>2.volatile保证原子性吗？</h4><p>&emsp;&emsp;从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>　　<br>&emsp;&emsp;下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		inc++;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">			<span class="keyword">new</span> Thread()&#123;  </span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">						test.increase();  </span><br><span class="line">				&#125;;  </span><br><span class="line">			&#125;.start();  </span><br><span class="line">		&#125;  </span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">			Thread.yield();  </span><br><span class="line">		System.out.println(test.inc);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>&emsp;&emsp;可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>&emsp;&emsp;这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>&emsp;&emsp;在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>&emsp;&emsp;假如某个时刻变量inc的值为10，</p>
<p>&emsp;&emsp;线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>&emsp;&emsp;然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>&emsp;&emsp;然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>&emsp;&emsp;那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>&emsp;&emsp;解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>&emsp;&emsp;根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>&emsp;&emsp;把上面的代码改成以下任何一种都可以达到效果：</p>
<p>&emsp;&emsp;采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		inc++;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">			<span class="keyword">new</span> Thread()&#123;  </span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">						test.increase();  </span><br><span class="line">				&#125;;  </span><br><span class="line">			&#125;.start();  </span><br><span class="line">		&#125;  </span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">			Thread.yield();  </span><br><span class="line">		System.out.println(test.inc);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;采用Lock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;  </span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		lock.lock();  </span><br><span class="line">		<span class="keyword">try</span> &#123;  </span><br><span class="line">			inc++;  </span><br><span class="line">		&#125; <span class="keyword">finally</span>&#123;  </span><br><span class="line">			lock.unlock();  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">			<span class="keyword">new</span> Thread()&#123;  </span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">						test.increase();  </span><br><span class="line">				&#125;;  </span><br><span class="line">			&#125;.start();  </span><br><span class="line">		&#125;  </span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">			Thread.yield();  </span><br><span class="line">		System.out.println(test.inc);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;采用AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		inc.getAndIncrement();  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();  </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">			<span class="keyword">new</span> Thread()&#123;  </span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)  </span><br><span class="line">						test.increase();  </span><br><span class="line">				&#125;;  </span><br><span class="line">			&#125;.start();  </span><br><span class="line">		&#125;  </span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完  </span></span><br><span class="line">			Thread.yield();  </span><br><span class="line">		System.out.println(test.inc);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h4 id="3-volatile能保证有序性吗？"><a href="#3-volatile能保证有序性吗？" class="headerlink" title="3.volatile能保证有序性吗？"></a>3.volatile能保证有序性吗？</h4><p>&emsp;&emsp;在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>&emsp;&emsp;volatile关键字禁止指令重排序有两层意思：</p>
<pre><code>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
</code></pre><p>&emsp;&emsp;可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量  </span></span><br><span class="line"><span class="comment">//flag为volatile变量  </span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1  </span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2  </span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3  </span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4  </span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>&emsp;&emsp;并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>&emsp;&emsp;那么我们回到前面举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:  </span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1  </span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:  </span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;  </span><br><span class="line">  sleep()  </span><br><span class="line">&#125;  </span><br><span class="line">doSomethingwithconfig(context);  </span><br><span class="line">````	</span><br><span class="line">	</span><br><span class="line">&amp;emsp;&amp;emsp;前面举这个例子的时候，提到有可能语句<span class="number">2</span>会在语句<span class="number">1</span>之前执行，那么就可能导致context还没被初始化，而线程<span class="number">2</span>中就使用未初始化的context去进行操作，导致程序出错。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;这里如果用<span class="keyword">volatile</span>关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句<span class="number">2</span>时，必定能保证context已经初始化完毕。</span><br><span class="line"><span class="number">4</span>.<span class="keyword">volatile</span>的原理和实现机制</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;前面讲述了源于<span class="keyword">volatile</span>关键字的一些使用，下面我们来探讨一下<span class="keyword">volatile</span>到底如何保证可见性和禁止指令重排序的。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;下面这段话摘自《深入理解Java虚拟机》：</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;“观察加入<span class="keyword">volatile</span>关键字和没有加入<span class="keyword">volatile</span>关键字时所生成的汇编代码发现，加入<span class="keyword">volatile</span>关键字时，会多出一个lock前缀指令”</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供<span class="number">3</span>个功能：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</span><br><span class="line">    <span class="number">2</span>）它会强制将对缓存的修改操作立即写入主存；</span><br><span class="line">    <span class="number">3</span>）如果是写操作，它会导致其他CPU中对应的缓存行无效。</span><br><span class="line">### 五.使用volatile关键字的场景</span><br><span class="line">&amp;emsp;&amp;emsp;<span class="keyword">synchronized</span>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<span class="keyword">volatile</span>关键字在某些情况下性能要优于<span class="keyword">synchronized</span>，但是要注意<span class="keyword">volatile</span>关键字是无法替代<span class="keyword">synchronized</span>关键字的，因为<span class="keyword">volatile</span>关键字无法保证操作的原子性。通常来说，使用<span class="keyword">volatile</span>必须具备以下<span class="number">2</span>个条件：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>）对变量的写操作不依赖于当前值</span><br><span class="line">    <span class="number">2</span>）该变量没有包含在具有其他变量的不变式中</span><br><span class="line">&amp;emsp;&amp;emsp;实际上，这些条件表明，可以被写入 <span class="keyword">volatile</span> 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;事实上，我的理解就是上面的<span class="number">2</span>个条件需要保证操作是原子性操作，才能保证使用<span class="keyword">volatile</span>关键字的程序在并发时能够正确执行。</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;下面列举几个Java中使用<span class="keyword">volatile</span>的几个场景。</span><br><span class="line"></span><br><span class="line">#### 1.状态标记量</span><br><span class="line"></span><br><span class="line">````java</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;  </span><br><span class="line">	doSomething();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	flag = <span class="keyword">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;  </span><br><span class="line"><span class="comment">//线程1:  </span></span><br><span class="line">context = loadContext();    </span><br><span class="line">inited = <span class="keyword">true</span>;              </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:  </span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;  </span><br><span class="line">	sleep()  </span><br><span class="line">&#125;  </span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<h4 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;  </span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">				<span class="keyword">if</span>(instance==<span class="keyword">null</span>)  </span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">return</span> instance;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;于为何;需要这么写请参考：</p>
<p>&emsp;&emsp;《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024和http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://blog.csdn.net/dl88250/article/details/5439024和http://www.iteye.com/topic/652440</a></p>
<p>&emsp;&emsp;参考资料：<br>　　《深入理解Java虚拟机》</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/枚举实现单例连接数据库/">枚举实现单例连接数据库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>创建一个jdbc.propertis文件，其内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driverClass = com.mysql.jdbc.Driver</span><br><span class="line">jdbcUrl = jdbc:mysql:<span class="comment">//localhost:3306/liaokailin</span></span><br><span class="line">user = root</span><br><span class="line">password = mysqladmin</span><br><span class="line">maxPoolSize = <span class="number">20</span></span><br><span class="line">minPoolSize = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>创建一个MyDataBaseSource的枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MyDataBaseSource &#123;</span><br><span class="line">	DATASOURCE;</span><br><span class="line">	<span class="keyword">private</span> ComboPooledDataSource cpds = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyDataBaseSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/*--------获取properties文件内容------------*/</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 方法一:</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * InputStream is =</span></span><br><span class="line"><span class="comment">			 * MyDBSource.class.getClassLoader().getResourceAsStream("jdbc.properties");</span></span><br><span class="line"><span class="comment">			 * Properties p = new Properties(); p.load(is);</span></span><br><span class="line"><span class="comment">			 * System.out.println(p.getProperty("driverClass") );</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 方法二：(不需要properties的后缀)</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * ResourceBundle rb = PropertyResourceBundle.getBundle("jdbc") ;</span></span><br><span class="line"><span class="comment">			 * System.out.println(rb.getString("driverClass"));</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 方法三：(不需要properties的后缀)</span></span><br><span class="line">			ResourceBundle rs = ResourceBundle.getBundle(<span class="string">"jdbc"</span>);</span><br><span class="line">			cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">			cpds.setDriverClass(rs.getString(<span class="string">"driverClass"</span>));</span><br><span class="line">			cpds.setJdbcUrl(rs.getString(<span class="string">"jdbcUrl"</span>));</span><br><span class="line">			cpds.setUser(rs.getString(<span class="string">"user"</span>));</span><br><span class="line">			cpds.setPassword(rs.getString(<span class="string">"password"</span>));</span><br><span class="line">			cpds.setMaxPoolSize(Integer.parseInt(rs.getString(<span class="string">"maxPoolSize"</span>)));</span><br><span class="line">			cpds.setMinPoolSize(Integer.parseInt(rs.getString(<span class="string">"minPoolSize"</span>)));    </span><br><span class="line">			 System.out.println(<span class="string">"-----调用了构造方法------"</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> cpds.getConnection();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyDataBaseSource.DATASOURCE.getConnection() ;</span><br><span class="line">		MyDataBaseSource.DATASOURCE.getConnection() ;</span><br><span class="line">		MyDataBaseSource.DATASOURCE.getConnection() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----调用了构造方法------</span><br><span class="line"><span class="number">2013</span>-<span class="number">7</span>-<span class="number">17</span> <span class="number">17</span>:<span class="number">10</span>:<span class="number">57</span> com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource getPoolManager</span><br><span class="line">信息: Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -&gt; <span class="number">3</span>, acquireRetryAttempts -&gt; <span class="number">30</span>, acquireRetryDelay -&gt; <span class="number">1000</span>, autoCommitOnClose -&gt; <span class="keyword">false</span>, automaticTestTable -&gt; <span class="keyword">null</span>, breakAfterAcquireFailure -&gt; <span class="keyword">false</span>, checkoutTimeout -&gt; <span class="number">0</span>, connectionCustomizerClassName -&gt; <span class="keyword">null</span>, connectionTesterClassName -&gt; com.mchange.v2.c3p0.impl.DefaultConnectionTester, dataSourceName -&gt; <span class="number">1</span>hge16d8v1tgb0wppydrzz|<span class="number">2</span>c1e6b, debugUnreturnedConnectionStackTraces -&gt; <span class="keyword">false</span>, description -&gt; <span class="keyword">null</span>, driverClass -&gt; com.mysql.jdbc.Driver, factoryClassLocation -&gt; <span class="keyword">null</span>, forceIgnoreUnresolvedTransactions -&gt; <span class="keyword">false</span>, identityToken -&gt; <span class="number">1</span>hge16d8v1tgb0wppydrzz|<span class="number">2</span>c1e6b, idleConnectionTestPeriod -&gt; <span class="number">0</span>, initialPoolSize -&gt; <span class="number">3</span>, jdbcUrl -&gt; jdbc:mysql:<span class="comment">//localhost:3306/kaoqin, maxAdministrativeTaskTime -&gt; 0, maxConnectionAge -&gt; 0, maxIdleTime -&gt; 0, maxIdleTimeExcessConnections -&gt; 0, maxPoolSize -&gt; 20, maxStatements -&gt; 0, maxStatementsPerConnection -&gt; 0, minPoolSize -&gt; 5, numHelperThreads -&gt; 3, preferredTestQuery -&gt; null, properties -&gt; &#123;user=******, password=******&#125;, propertyCycle -&gt; 0, statementCacheNumDeferredCloseThreads -&gt; 0, testConnectionOnCheckin -&gt; false, testConnectionOnCheckout -&gt; false, unreturnedConnectionTimeout -&gt; 0, usesTraditionalReflectiveProxies -&gt; false ]</span></span><br></pre></td></tr></table></figure></p>
<p>很显然获得了三个Connection连接，但是只调用了一次枚举的构造方法,从而通过枚举实现了单例的设计</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/解决maven依赖/">解决maven依赖</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>[toc]</p>
<p>依赖过滤</p>
<p>（1）单依赖过滤</p>
<pre><code>同依赖过滤直接处理：可以过滤一个或者多个，如果过滤多个要写多个&lt;exclusion&gt;。这个也解决不了我的问题，或者说解决太麻烦，我那里知道hbase要依赖那些包，记不住。
</code></pre><p>Java代码  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.94.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>    </span><br><span class="line">           <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>        </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>            </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">           <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>    </span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）多依赖过滤</p>
<pre><code>把所以依赖都过滤了。手起刀落~啊，世界都安静了。
</code></pre><p>Java代码  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hbase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hbase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.94.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/编码与乱码/">编码与乱码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>[toc]</p>
<h3 id="乱码的根源"><a href="#乱码的根源" class="headerlink" title="乱码的根源"></a>乱码的根源</h3><p>源编码与目标编码的不一致. 而中文window系统默认编码GBK,害惨了多少程序员.</p>
<p>要尽量减少出现乱码,我个人认为要做到5码合一, IDE(Eclipse/idea),页面(jsp/其他模板引擎),应用服务器(tomcat等), 源码(Java源码及周边文件),数据库编码.</p>
<h3 id="将Eclipse设置为UTF-8"><a href="#将Eclipse设置为UTF-8" class="headerlink" title="将Eclipse设置为UTF-8"></a>将Eclipse设置为UTF-8</h3><p>打开Eclipse安装目录下的eclipse.ini,在最末尾新增一行</p>
<pre><code>-Dfile.encoding=UTF-8
</code></pre><p>修改之后的,重启eclipse即可.</p>
<h3 id="JSP页面编码"><a href="#JSP页面编码" class="headerlink" title="JSP页面编码"></a>JSP页面编码</h3><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
可以设置eclipse的jsp设置
</code></pre><h3 id="tomcat编码"><a href="#tomcat编码" class="headerlink" title="tomcat编码"></a>tomcat编码</h3><p>打开 tomcat安装目录下的 binsetenv.bat ,该文件通常不存在,新建之, 添加如下内容</p>
<pre><code>set JAVA_OPTS=-Dfile.encoding=UTF-8
</code></pre><p>打开confserver.conf, 在8080端口所属的Connector节点,添加URIEncoding,可解决大部分GET请求中文乱码的问题</p>
<pre><code>URIEncoding=&quot;UTF-8&quot;
</code></pre><h3 id="源码的编码"><a href="#源码的编码" class="headerlink" title="源码的编码"></a>源码的编码</h3><p>通常情况下, 文件本身的编码,取决于新建文件时,IDE或Project的编码.</p>
<p>另外一个隐藏的编码,是maven/ant编译java源文件时使用的编码</p>
<p>maven的配置如下</p>
<pre><code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
</code></pre><h3 id="数据库编码"><a href="#数据库编码" class="headerlink" title="数据库编码"></a>数据库编码</h3><p>通常来说,如果其他4码解决了,那大部分情况下是mysql会出现编码问题</p>
<p>mysql有4个编码</p>
<pre><code>Server characterset:    utf8      // 服务器字节集
Db     characterset:    utf8      // 当前数据集字节集
Client characterset:    utf8      // 客户端字节集
Conn.  characterset:    utf8      // 当前连接的字节集
</code></pre><p>修改my.ini的mysqld小节,设置服务器字符集,是最佳解决方式</p>
<pre><code>[mysqld]
character-set-server = utf8
</code></pre><p>然而,对于现有系统,全局修改的风险比较大,所以,可以在客户端解决,即jdbcurl上做配置</p>
<pre><code>jdbc:mysql://127.0.0.1/nutzdemo?useUnicode=true&amp;characterEncoding=UTF-8
</code></pre><h3 id="Nutz的相关日志"><a href="#Nutz的相关日志" class="headerlink" title="Nutz的相关日志"></a>Nutz的相关日志</h3><p>nutz在启动时也会打印周围的编码信息,帮助排查.</p>
<pre><code>21:22:23.235 INFO  (NutLoading.java:55) load - Nutz Version : 1.r.59 
21:22:23.235 INFO  (NutLoading.java:56) load - Nutz.Mvc[nutz] is initializing ...
21:22:23.235 DEBUG (NutLoading.java:60) load - Web Container Information:
21:22:23.237 DEBUG (NutLoading.java:61) load -  - Default Charset : UTF-8
21:22:23.237 DEBUG (NutLoading.java:62) load -  - Current . path  : D:\nutzbook\eclipse\.
21:22:23.237 DEBUG (NutLoading.java:63) load -  - Java Version    : 1.8.0_112
21:22:23.237 DEBUG (NutLoading.java:65) load -  - Timezone        : Asia/Shanghai
21:22:23.238 DEBUG (NutLoading.java:66) load -  - OS              : Windows 7 amd64
21:22:23.238 DEBUG (NutLoading.java:67) load -  - ServerInfo      : Apache Tomcat/9.0.0.M13
21:22:23.238 DEBUG (NutLoading.java:68) load -  - Servlet API     : 4.0
21:22:23.238 DEBUG (NutLoading.java:73) load -  - ContextPath     : /nutzbook
21:22:25.134 DEBUG (DaoSupport.java:199) invoke - JDBC Name   --&gt; MySQL Connector Java
21:22:25.135 DEBUG (DaoSupport.java:201) invoke - JDBC URL    --&gt; jdbc:mysql://127.0.0.1:3306/nutzbook
21:22:25.145 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_client=utf8
21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_connection=utf8
21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_database=utf8
21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_filesystem=binary
21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_results=
21:22:25.146 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_server=utf8
21:22:25.147 DEBUG (MysqlJdbcExpert.java:212) checkDataSource - Mysql : character_set_system=utf8
</code></pre><p>Default Charset的编码,在Eclipse环境内, 通过eclipse.ini调整,在tomcat内的话,通过setenv.bat调整.</p>
<p>mysql的编码,通过修改my.ini或jdbc url进行调整</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/sql/">sql</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>[toc]</p>
<h4 id="时间分区表查询出指定日期-精确到天-的数据量"><a href="#时间分区表查询出指定日期-精确到天-的数据量" class="headerlink" title="时间分区表查询出指定日期(精确到天)的数据量"></a>时间分区表查询出指定日期(精确到天)的数据量</h4><p>数据库有一列为</p>
<p><img src="https://ooo.0o0.ooo/2017/06/02/5930dc8090c95.png" alt="下载.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select count(*) from "</span>+libraryName+<span class="string">"."</span>+schemaName+<span class="string">"."</span> +tableName+<span class="string">" where to_char(OCCUR_TIME,'yyyy-mm-dd')='"</span>+dateStr+<span class="string">"'"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="小松鼠执行hive-sql的时候出现missing-EFO-near…"><a href="#小松鼠执行hive-sql的时候出现missing-EFO-near…" class="headerlink" title="小松鼠执行hive sql的时候出现missing EFO near…"></a>小松鼠执行hive sql的时候出现missing EFO near…</h4><p>注意sql栏的状态是否上边藏了几个sql，有的话清掉。</p>
<h4 id="Hbase的sql时间查询-查询某天的-HAPPENTIME类型为-TIMESTAMP"><a href="#Hbase的sql时间查询-查询某天的-HAPPENTIME类型为-TIMESTAMP" class="headerlink" title="Hbase的sql时间查询  查询某天的 HAPPENTIME类型为:TIMESTAMP"></a>Hbase的sql时间查询  查询某天的 HAPPENTIME类型为:TIMESTAMP</h4><pre><code>select * from FJUDM4.HBASE_MD_OMS_T_COMBINEMONITOR_BUG where HAPPENTIME&gt;=to_date(&apos;2016-10-12 00:00:00&apos;) and HAPPENTIME&lt;to_date(&apos;2016-10-13 00:00:00&apos;)
</code></pre><p><img src="https://ooo.0o0.ooo/2017/06/02/5930dc8079553.png" alt="下载 (1).png"></p>
<h4 id="hive的sql时间分区查询"><a href="#hive的sql时间分区查询" class="headerlink" title="hive的sql时间分区查询"></a>hive的sql时间分区查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from fjudm4.hbase_md_all_op_ctrl where occur_time &gt;= <span class="number">2016</span>-<span class="number">11</span>-<span class="number">01</span> and occur_time &lt; <span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span></span><br><span class="line">没有加单引号报错</span><br><span class="line"></span><br><span class="line">select * from fjudm4.hbase_md_all_op_ctrl where occur_time = <span class="string">'2016-11-01'</span></span><br><span class="line">不可以直接用=</span><br><span class="line"></span><br><span class="line">select * from fjudm4.hbase_md_all_op_ctrl where occur_time &gt;= <span class="string">'2016-11-01'</span> and occur_time &lt; <span class="string">'2016-11-02'</span></span><br><span class="line">正确语法</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/spark学习记录/">spark学习记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>[toc]</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p> 用spark-submit命令提交任务运行，具体使用查看：spark-submit –help</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  --master MASTER_URL         spark:<span class="comment">//host:port, mesos://host:port, yarn, or local.</span></span><br><span class="line">  --deploy-<span class="function">mode DEPLOY_MODE   Whether to launch the driver program <span class="title">locally</span> <span class="params">(<span class="string">"client"</span>)</span> or</span></span><br><span class="line"><span class="function">                              on one of the worker machines inside the <span class="title">cluster</span> <span class="params">(<span class="string">"cluster"</span>)</span></span></span><br><span class="line"><span class="function">                              <span class="params">(Default: client)</span>.</span></span><br><span class="line"><span class="function">  --class CLASS_NAME          Your application's main <span class="title">class</span> <span class="params">(<span class="keyword">for</span> Java / Scala apps)</span>.</span></span><br><span class="line"><span class="function">  --name NAME                 A name of your application.</span></span><br><span class="line"><span class="function">  --jars JARS                 Comma-separated list of local jars to include on the driver</span></span><br><span class="line"><span class="function">                              and executor classpaths.</span></span><br><span class="line"><span class="function">  --packages                  Comma-separated list of maven coordinates of jars to include</span></span><br><span class="line"><span class="function">                              on the driver and executor classpaths. Will search the local</span></span><br><span class="line"><span class="function">                              maven repo, then maven central and any additional remote</span></span><br><span class="line"><span class="function">                              repositories given by --repositories. The format <span class="keyword">for</span> the</span></span><br><span class="line"><span class="function">                              coordinates should be groupId:artifactId:version.</span></span><br><span class="line"><span class="function">  --exclude-packages          Comma-separated list of groupId:artifactId, to exclude <span class="keyword">while</span></span></span><br><span class="line"><span class="function">                              resolving the dependencies provided in --packages to avoid</span></span><br><span class="line"><span class="function">                              dependency conflicts.</span></span><br><span class="line"><span class="function">  --repositories              Comma-separated list of additional remote repositories to</span></span><br><span class="line"><span class="function">                              search <span class="keyword">for</span> the maven coordinates given with --packages.</span></span><br><span class="line"><span class="function">  --py-files PY_FILES         Comma-separated list of .zip, .egg, or .py files to place</span></span><br><span class="line"><span class="function">                              on the PYTHONPATH <span class="keyword">for</span> Python apps.</span></span><br><span class="line"><span class="function">  --files FILES               Comma-separated list of files to be placed in the working</span></span><br><span class="line"><span class="function">                              directory of each executor.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --conf PROP</span>=VALUE           Arbitrary Spark configuration property.</span><br><span class="line">  --properties-file FILE      Path to a file from which to load extra properties. If not</span><br><span class="line">                              specified, <span class="keyword">this</span> will look <span class="keyword">for</span> conf/spark-defaults.conf.</span><br><span class="line"></span><br><span class="line">  --driver-<span class="function">memory MEM         Memory <span class="keyword">for</span> <span class="title">driver</span> <span class="params">(e.g. <span class="number">1000</span>M, <span class="number">2</span>G)</span> <span class="params">(Default: <span class="number">1024</span>M)</span>.</span></span><br><span class="line"><span class="function">  --driver-java-options       Extra Java options to pass to the driver.</span></span><br><span class="line"><span class="function">  --driver-library-path       Extra library path entries to pass to the driver.</span></span><br><span class="line"><span class="function">  --driver-class-path         Extra class path entries to pass to the driver. Note that</span></span><br><span class="line"><span class="function">                              jars added with --jars are automatically included in the</span></span><br><span class="line"><span class="function">                              classpath.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --executor-memory MEM       Memory per <span class="title">executor</span> <span class="params">(e.g. <span class="number">1000</span>M, <span class="number">2</span>G)</span> <span class="params">(Default: <span class="number">1</span>G)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --proxy-user NAME           User to impersonate when submitting the application.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  --help, -h                  Show <span class="keyword">this</span> help message and exit</span></span><br><span class="line"><span class="function">  --verbose, -v               Print additional debug output</span></span><br><span class="line"><span class="function">  --version,                  Print the version of current Spark</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone with cluster deploy mode only:</span></span><br><span class="line"><span class="function">  --driver-cores NUM          Cores <span class="keyword">for</span> <span class="title">driver</span> <span class="params">(Default: <span class="number">1</span>)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone or Mesos with cluster deploy mode only:</span></span><br><span class="line"><span class="function">  --supervise                 If given, restarts the driver on failure.</span></span><br><span class="line"><span class="function">  --kill SUBMISSION_ID        If given, kills the driver specified.</span></span><br><span class="line"><span class="function">  --status SUBMISSION_ID      If given, requests the status of the driver specified.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone and Mesos only:</span></span><br><span class="line"><span class="function">  --total-executor-cores NUM  Total cores <span class="keyword">for</span> all executors.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> Spark standalone and YARN only:</span></span><br><span class="line"><span class="function">  --executor-cores NUM        Number of cores per executor. <span class="params">(Default: <span class="number">1</span> in YARN mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                              or all available cores on the worker in standalone mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> YARN-only:</span></span><br><span class="line"><span class="function">  --driver-cores NUM          Number of cores used by the driver, only in cluster mode</span></span><br><span class="line"><span class="function">                              <span class="params">(Default: <span class="number">1</span>)</span>.</span></span><br><span class="line"><span class="function">  --queue QUEUE_NAME          The YARN queue to submit <span class="title">to</span> <span class="params">(Default: <span class="string">"default"</span>)</span>.</span></span><br><span class="line"><span class="function">  --num-executors NUM         Number of executors to <span class="title">launch</span> <span class="params">(Default: <span class="number">2</span>)</span>.</span></span><br><span class="line"><span class="function">  --archives ARCHIVES         Comma separated list of archives to be extracted into the</span></span><br><span class="line"><span class="function">                              working directory of each executor.</span></span><br><span class="line"><span class="function">  --principal PRINCIPAL       Principal to be used to login to KDC, <span class="keyword">while</span> running on</span></span><br><span class="line"><span class="function">                              secure HDFS.</span></span><br><span class="line"><span class="function">  --keytab KEYTAB             The full path to the file that contains the keytab <span class="keyword">for</span> the</span></span><br><span class="line"><span class="function">                              principal specified above. This keytab will be copied to</span></span><br><span class="line"><span class="function">                              the node running the Application Master via the Secure</span></span><br><span class="line"><span class="function">                              Distributed Cache, <span class="keyword">for</span> renewing the login tickets and the</span></span><br><span class="line"><span class="function">                              delegation tokens periodically.</span></span><br></pre></td></tr></table></figure>
<h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p> Initial job has not accepted any resources; check your cluster UI to ensure that workers are registered and have sufficient resources</p>
<pre><code>当前的集群的可用资源不能满足应用程序所请求的资源。我spark submit的时候给的资源太大了

资源分2类： cores 和 ram
Core代表对执行可用的executor slots
Ram代表每个Worker上被需要的空闲内存来运行你的Application。
解决方法：
应用不要请求多余空闲可用资源的
关闭掉已经执行结束的Application
</code></pre><h3 id="spark-submit执行命令"><a href="#spark-submit执行命令" class="headerlink" title="spark-submit执行命令"></a>spark-submit执行命令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master spark:<span class="comment">//FJ-DCLOUD-HDP01:7077 --conf "spark.scheduler.mode=FAIR" --total-executor-cores 8 --driver-memory 20g --executor-memory 20g /home/yarn/dev/cyb/a.jar </span></span><br><span class="line"></span><br><span class="line">a.jar不需要jar包   所要用的jar包放到spark服务器的lib下  例如：</span><br><span class="line">/home/yarn/spark-<span class="number">1.5</span>.2-bin-hadoop2.6/lib</span><br><span class="line">命令会默认读取改路径下的jar</span><br><span class="line">关于此设置的配置 见下条</span><br></pre></td></tr></table></figure>
<h3 id="spark-submit指定服务器jar包配置"><a href="#spark-submit指定服务器jar包配置" class="headerlink" title="spark-submit指定服务器jar包配置"></a>spark-submit指定服务器jar包配置</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[yarn@EPRI-DCLOUD-ETL01 conf]$ pwd</span><br><span class="line">/home/yarn/spark-<span class="number">1.5</span>.<span class="number">2</span>-bin-hadoop2.<span class="number">6</span>/conf</span><br><span class="line">[root@EPRI-DCLOUD-ETL01 conf]<span class="comment"># ls</span></span><br><span class="line">docker.properties.template  fairscheduler.xml.template  hive-site.xml  log4j.properties  metrics.properties.template  slaves  spark-defaults.conf  spark-env.sh</span><br><span class="line">[root@EPRI-DCLOUD-ETL01 conf]<span class="comment"># vi spark-env.sh </span></span><br><span class="line"></span><br><span class="line">export SPARK_YARN_MODE=true</span><br><span class="line">export MASTER=yarn-client</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_55</span><br><span class="line">export SCALA_HOME=/usr/share/scala-<span class="number">2.11</span>.<span class="number">6</span></span><br><span class="line">export SPARK_MASTER_IP=EPRI-DCLOUD-HDP01</span><br><span class="line">export SPARK_CLASSPATH=<span class="variable">$SPARK_CLASSPATH:</span>/usr/share/spark-<span class="number">1.5</span>.<span class="number">2</span>-bin-hadoop2.<span class="number">6</span>/lib/*:/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/*:/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/etc/*:/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/lib/*</span><br><span class="line">export HADOOP_HOME=/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>export HADOOP_CONF_DIR=/usr/share/hadoop-<span class="number">2.6</span>.<span class="number">0</span>/etc/hadoop</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/MariaDB安装及操作/">MariaDB安装及操作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>[toc]</p>
<h3 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件"></a>准备软件</h3><pre><code>cupid-mariadb-5.5.52
mariadb-5.5.31-winx64
</code></pre><h3 id="安装步奏"><a href="#安装步奏" class="headerlink" title="安装步奏"></a>安装步奏</h3><p>解压缩软件<br>文件夹中，一般包含5个MySQL自带的配置文件，</p>
<pre><code>my-small.ini、my-medium.ini、my-large.ini、my-huge.ini和my-innodb-heavy-4G.ini，
</code></pre><p>请你根据自己机器的内存大小，选择其一，并把它重新命名为my.ini用作基本配置文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[WinMySQLAdmin]</span><br><span class="line">Server=D:\YuanBo_Chi\mariadb-<span class="number">5.5</span>.31-winx64\bin\mysqld.exe</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">#password	= [your_password]</span><br><span class="line">port		= <span class="number">3306</span></span><br><span class="line">socket		= /tmp/mysql.sock</span><br><span class="line"><span class="keyword">default</span>-character-set=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"># *** Application-specific options follow here ***</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># The MariaDB server</span><br><span class="line">#</span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># generic configuration options</span><br><span class="line">port		= <span class="number">3306</span></span><br><span class="line">socket		= /tmp/mysql.sock</span><br><span class="line">basedir=D:\YuanBo_Chi\mariadb-<span class="number">5.5</span>.31-winx64</span><br><span class="line">datadir=D:\YuanBo_Chi\mariadb-<span class="number">5.5</span>.31-winx64\data</span><br><span class="line"><span class="keyword">default</span>-character-set=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>在目录下运行 mysqld –install servicename则会创建名为servicename的Windows服务。我使用的是</p>
<pre><code>mysqld --install MariaDB 
</code></pre><p>等待成功后，<br>输入 </p>
<pre><code>net start MariaDB 
</code></pre><p>即可启动服务开始你的MariaDB之旅了。<br> 如果需要停止该服务，</p>
<p> 输入 </p>
<pre><code>net stop MariaDB 
</code></pre><p>即可停止服务<br>将创建完的服务的启动类型设为自动启动，并启动MariaDB。启动MariaDB时，会在data目录内创建数据文件和日志文件。</p>
<p>注：启动后的MariaDB 有一个默认的 root用户，其访问密码为空。修改密码的方法与MySQL类似，执行如下命令，即可修改root的访问密码。</p>
<pre><code>mysqladmin -u root password &quot;root&quot;
</code></pre><p>顺便提一句，删除的时候也很简单，输入 </p>
<pre><code>mysqld.exe --remove MariaDB
</code></pre><p>即可    </p>
<h3 id="图形化操作"><a href="#图形化操作" class="headerlink" title="图形化操作"></a>图形化操作</h3><p>下载Navicat Premium</p>
<p>链接MariaDB</p>
<p><img src="http://i4.buimg.com/1949/8e38fb3dd22b97d8.png" alt="Markdown"></p>
<p>ok</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/LOG4J/">Log4j</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：YuanBo-Chi/">作者：YuanBo-Chi</a></span><div class="content"><p>[toc]</p>
<h3 id="个人配置"><a href="#个人配置" class="headerlink" title="个人配置"></a>个人配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">### 设置###</span><br><span class="line">log4j.rootLogger = info,stdout,D</span><br><span class="line"></span><br><span class="line">### 输出信息到控制抬 ###</span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern = [%-<span class="number">5</span>p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class="line"></span><br><span class="line">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><br><span class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.D.Append = <span class="keyword">true</span></span><br><span class="line">log4j.appender.D.Threshold = DEBUG</span><br><span class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"></span><br><span class="line">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br></pre></td></tr></table></figure>
<h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>日志记录器(Logger)是日志处理的核心组件。log4j具有5种正常级别(Level)。日志记录器(Logger)的可用级别Level (不包括自定义级别 Level)， 以下内容就是摘自log4j API (<a href="http://jakarta.apache.org/log4j/docs/api/index.html)" target="_blank" rel="noopener">http://jakarta.apache.org/log4j/docs/api/index.html)</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Level WARN</span><br><span class="line">WARN level表明会出现潜在错误的情形。</span><br><span class="line"><span class="keyword">static</span> Level ERROR</span><br><span class="line">ERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。</span><br><span class="line"><span class="keyword">static</span> Level FATAL</span><br><span class="line">FATAL level指出每个严重的错误事件将会导致应用程序的退出。</span><br><span class="line">另外，还有两个可用的特别的日志记录级别: (以下描述来自log4j APIhttp:<span class="comment">//jakarta.apache.org/log4j/docs/api/index.html):</span></span><br><span class="line"><span class="keyword">static</span> Level ALL</span><br><span class="line">ALL Level是最低等级的，用于打开所有日志记录。</span><br><span class="line"><span class="keyword">static</span> Level OFF</span><br><span class="line">OFF Level是最高等级的，用于关闭所有日志记录。</span><br></pre></td></tr></table></figure>
<p>日志记录器（Logger）的行为是分等级的。如下表所示：<br>分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来，也是说大于等于的级别的日志才输出。</p>
<p>日志记录的级别有继承性，子类会记录父类的所有的日志级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">logger日志设置：</span><br><span class="line"><span class="number">1</span>、加包：log4j-<span class="number">1.2</span>.16.jar  一般还会加入 commons-logging-<span class="number">1.1</span>.1.jar</span><br><span class="line"><span class="number">2</span>、在CLASSPATH 下建立log4j.properties</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.stdout.Target=System.out  </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d %<span class="number">5</span>p %c&#123;<span class="number">1</span>&#125;:%L - %m%n  </span><br><span class="line"></span><br><span class="line">log4j.appender.file=org.apache.log4j.RollingFileAppender  </span><br><span class="line">log4j.appender.file.File=$&#123;catalina.home&#125;/logs/ddoMsg.log  </span><br><span class="line">#log4j.appender.file.File=D:/SmgpAppService/logs/smgpApp.log  </span><br><span class="line">log4j.appender.file.MaxFileSize=<span class="number">1024</span>KB  </span><br><span class="line">log4j.appender.file.MaxBackupIndex=<span class="number">100</span>  </span><br><span class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.file.layout.ConversionPattern= %d&#123;yyyy-MM-dd HH:mm:ss&#125; %<span class="number">5</span>p %c %t: - %m%n  </span><br><span class="line"></span><br><span class="line">#INFO WARN ERROR DEBUG  </span><br><span class="line">log4j.rootLogger=WARN, file, stdout  </span><br><span class="line">#log4j.rootLogger=INFO,stdout  </span><br><span class="line">org.apache.commons.logging.Log=org.apache.commons.logging.impl.SimpleLog  </span><br><span class="line">#org.apache.commons.logging.simplelog.log.org.apache.commons.digester.Digester=debug  </span><br><span class="line">#org.apache.commons.logging.simplelog.log.org.apache.commons.digester.ObjectCreateRule=debug  </span><br><span class="line">#org.apache.commons.logging.simplelog.log.org.apache.commons.digester.Digester.sax=info  </span><br><span class="line"></span><br><span class="line">log4j.logger.com.jason.ddoMsg=debug</span><br></pre></td></tr></table></figure>
<p>在要输出的日志的类中<br>定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.log4j.Logger logger = Logger.getLogger(类名.class);</span><br><span class="line">在类输位置：logger.info(XXX);</span><br></pre></td></tr></table></figure>
<p>logger 配置说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、 log4j.rootLogger=INFO, stdout , R</span><br><span class="line"></span><br><span class="line">此句为将等级为INFO的日志信息输出到stdout和R这两个目的地，stdout和R的定义在下面的代码，可以任意起名。等级可分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL，如果配置OFF则不打出任何信息，如果配置为INFO这样只显示INFO, WARN, ERROR的log信息，而DEBUG信息不会被显示，具体讲解可参照第三部分定义配置文件中的logger。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line"></span><br><span class="line">此句为定义名为stdout的输出端是哪种类型，可以是</span><br><span class="line"></span><br><span class="line">org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.FileAppender（文件），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</span><br><span class="line"></span><br><span class="line">org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">此句为定义名为stdout的输出端的layout是哪种类型，可以是</span><br><span class="line"></span><br><span class="line">org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="line"></span><br><span class="line">org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、log4j.appender.stdout.layout.ConversionPattern= [QC] %p [%t] %C.%M(%L) | %m%n</span><br><span class="line"></span><br><span class="line">如果使用pattern布局就要指定的打印信息的具体格式ConversionPattern，打印参数如下：</span><br><span class="line"></span><br><span class="line">%m 输出代码中指定的消息</span><br><span class="line"></span><br><span class="line">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL</span><br><span class="line"></span><br><span class="line">%r 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line"></span><br><span class="line">%c 输出所属的类目，通常就是所在类的全名</span><br><span class="line"></span><br><span class="line">%t 输出产生该日志事件的线程名</span><br><span class="line"></span><br><span class="line">%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”</span><br><span class="line"></span><br><span class="line">%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyyy MMM dd HH:mm:ss,SSS&#125;，输出类似：<span class="number">2002</span>年<span class="number">10</span>月<span class="number">18</span>日 <span class="number">22</span>：<span class="number">10</span>：<span class="number">28</span>，<span class="number">921</span></span><br><span class="line"></span><br><span class="line">%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。</span><br><span class="line"></span><br><span class="line">[QC]是log信息的开头，可以为任意字符，一般为项目简称。</span><br><span class="line"></span><br><span class="line">输出的信息</span><br><span class="line"></span><br><span class="line">[TS] DEBUG [main] AbstractBeanFactory.getBean(<span class="number">189</span>) | Returning cached instance of singleton bean <span class="string">'MyAutoProxy'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、 log4j.appender.R=org.apache.log4j.DailyRollingFileAppender</span><br><span class="line"></span><br><span class="line">此句与第<span class="number">3</span>行一样。定义名为R的输出端的类型为每天产生一个日志文件。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、log4j.appender.R.File=D:\\Tomcat <span class="number">5.5</span>\\logs\\qc.log</span><br><span class="line"></span><br><span class="line">此句为定义名为R的输出端的文件名为D:\\Tomcat <span class="number">5.5</span>\\logs\\qc.log可以自行修改。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、 log4j.appender.R.layout=org.apache.log4j.PatternLayout</span><br><span class="line"></span><br><span class="line">与第<span class="number">4</span>行相同。</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>、 log4j.appender.R.layout.ConversionPattern=%d-[TS] %p %t %c - %m%n</span><br><span class="line"></span><br><span class="line">与第<span class="number">5</span>行相同。</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>、 log4j.logger.com. neusoft =DEBUG</span><br><span class="line"></span><br><span class="line">指定com.neusoft包下的所有类的等级为DEBUG。</span><br><span class="line"></span><br><span class="line">可以把com.neusoft改为自己项目所用的包名。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、  log4j.logger.com.opensymphony.oscache=ERROR</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、 log4j.logger.NET.sf.navigator=ERROR</span><br><span class="line"></span><br><span class="line">这两句是把这两个包下出现的错误的等级设为ERROR，如果项目中没有配置EHCache，则不需要这两句。</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、log4j.logger.org.apache.commons=ERROR</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>、 log4j.logger.org.apache.struts=WARN</span><br><span class="line"></span><br><span class="line">这两句是struts的包。</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>、  log4j.logger.org.displaytag=ERROR</span><br><span class="line"></span><br><span class="line">这句是displaytag的包。（QC问题列表页面所用）</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>、 log4j.logger.org.springframework=DEBUG</span><br><span class="line"></span><br><span class="line">此句为spring的包。</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>、 log4j.logger.org.hibernate.ps.PreparedStatementCache=WARN</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>、log4j.logger.org.hibernate=DEBUG</span><br><span class="line"></span><br><span class="line">此两句是hibernate的包。</span><br><span class="line"></span><br><span class="line">以上这些包的设置可根据项目的实际情况而自行定制。</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/JVM性能优化， Part 5  ―― Java的伸缩性/">JVM性能优化， Part 5  ―― Java的伸缩性</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：Eva-Andreasson-译者：吴杰/">作者：Eva Andreasson,译者：吴杰</a></span><div class="content"><p>很多程序员在解决JVM性能问题的时候，花开了很多时间去调优应用程序级别的性能瓶颈，当你读完这本系列文章之后你会发现我可能更加系统地看待这类的问题。我说过JVM的自身技术限制了Java企业级应用的伸缩性。首先我们先列举一些主导因素。</p>
<ul>
<li><p>主流的硬件服务器提供了大量的内存</p>
</li>
<li><p>分布式系统有大量内存的需求，而且该需求在持续增长</p>
</li>
<li><p>一个普通Java应用程序所持有的对空间大概在1GB~4GB，这远远低于一个硬件服务器的内存管理能力以及一个分布式应用程序的内存需求量。这被称之为Java内存墙，如下图所示(图中表述Java应用服务器和常规Java应用的内存使用量的演变史)。</p>
</li>
</ul>
<p><img src="http://osapnihnq.bkt.clouddn.com/blog/180423/aH8h1m3BJ4.png?imageslim" alt="mark"></p>
<p>Java内存墙(1980~2010)   (图片来源：Azul Systems)</p>
<p>这给我们带来了如下JVM性能课题：</p>
<p>1) 如果分配给应用程序的内存太小，将导致内存不足。JVM 不能及时释放内存空间给应用程序，最终将引发内存不足，或者JVM完全关闭。所以你必须提供更多的内存给应用程序。</p>
<p>2) 如果给对响应时间敏感的应用增加内存，如果不重启你的系统或者优化你的应用，Java堆最终会碎片化。当碎片发生时，可能会导致应用中断100毫秒~100秒，这取决与你的Java应用，Java堆的大小以及其他的JVM调优参数。</p>
<p>关于停顿的讨论大部分都集中在平均停顿或者目标停顿，很少涉及到堆压缩时的最坏停顿时间，在生产环境中堆中每千兆字节的有效数据的都将会发生大约1秒的停顿。</p>
<p>2 ~ 4秒的停顿对大多数企业应用来说都是不能接受的，所以尽管实际的Java应用实例可能需要更多的内存空间，但实际只分配2~4GB的内存。在一些64位系统中带有很多关于伸缩性的JVM调优项，使得这些系统可以运行16GB乃至20GB的堆空间，并能满足典型响应时间的SLA。但是这些离现实较远，JVM目前的技术无法在进行堆压缩时避免停顿应用程序。Java应用开发人员苦于处理这两个为我们大多数人所抱怨的任务。</p>
<ul>
<li><p>架构/建模在大量的实例池之上，随之而来的是复杂的监控和管理操作。</p>
</li>
<li><p>反复的JVM和应用程序调优以避免“stop the world“引起的停顿。大多数程序员希望停顿不要发生在系统峰值负载期间。我称之为不可能的目标。</p>
</li>
</ul>
<p>现在让我们深入一点Java的可伸缩性问题。</p>
<p><strong>过度供给或过度实例化Java部署</strong></p>
<p>为了充分利用内存资源，普通的做法是将Java应用部署在多个应用服务器实例上而不是一个或者少数应用服务器实例上。当一台Server上运行16个应用服务器实例可以充分利用所有的内存资源，但如此无法解决的是多实例的监控以及管理所带来的成本，尤其是当你的应用部署在多个Server上。</p>
<p>另一个问题来了，峰值负载时的内存资源不是每天都需要的，这样就形成了巨大的浪费。有些情况下，一台物理机上可能只不是不超过3个“大应用服务器实例”，这样的部署更加不够经济也不够环保，尤其在非峰值负载期间。</p>
<p>让我们来比较一下这两种部署架构，下图中左边是多而小的应用服务器实例部署模式，右边是少而大的应用服务器实例部署模式。两种模式处理同样的负载，究竟哪一种部署架构更具经济性。</p>
<p><img src="http://osapnihnq.bkt.clouddn.com/blog/180423/c09mCc1LCK.png?imageslim" alt="mark"></p>
<p>大应用服务器部署场景 (图片来源：Azul Systems)</p>
<p>如我之前说过的，并发压缩使得大应用服务器部署模式变得可行，而且可以突破JVM可伸缩性的限制。目前只有Azul的Zing JVM可以提供并发压缩的技术，另外Zing是Server侧的JVM，我们很乐意看到越来越多的开发者在JVM层面去挑战Java可伸缩性的问题。</p>
<p>由于性能调优仍然是我们解决Java可伸缩性问题的主要手段，我们先来看有哪些主要的调优参数以及通过它们能达到什么样的效果。</p>
<p><strong>调优参数：一些事例</strong></p>
<p>最著名的调优参数莫过于”-Xmx”了，通过该参数可以指定Java的堆空间大小，实际上可能不同的JVM执行结果不太一样。</p>
<p>有的JVM包含了内部结构(如编译器线程，垃圾回收器结构，代码缓存等等)所需要的内存在“-Xmx”的设定中，而有的则不包含。因此用户Java进程的大小不一定跟“-Xmx”的设定相吻合。</p>
<p>如果你的应用程序分配对象的速率，对象的生命周期，或者对象的大小超过了JVM内存相关配置，一旦达到最大可使用内存的阈值将会发生内存溢出，用户进程则会停止。</p>
<p>当你的应用程序纠结于内存的可用性时，最有效的方法就是通过”-Xmx”指定更大的内存去重启当前应用进程。为了避免频繁的重启，大多数企业生产环境都倾向于指定峰值负载时所需要的内存，造成过度配置优化。</p>
<p><strong>提示：</strong>生产环境负载的调整</p>
<p>Java开发人员易犯的常见错误是在实验下的做的堆内存设置，在移植到生产环境是忘记重新调整。生产环境和实验室环境是不一样的，谨记根据生产环境的负载重新调整堆内存设置。</p>
<p><strong>分代垃圾回收器调优</strong></p>
<p>还有一些其他的优化选项”-Xns”和”-XX: NewSize”，用来调整年轻代的大小，用来指定堆中专门负责新对象分配的空间大小。</p>
<p>大多数开发者都试图基于实验室环境调整年轻代的大小，这意味着在生产负载下存在失败的风险。一般新生代的大小设置为堆大小的三分之一至二分之一左右，但这不是一个准则，毕竟实际还要视应用程序逻辑而定。因此最好先调查清楚年轻代到年老代的蜕变率以及年老代对象的大小，在此基础上(确保年老代的大小，年老代过小会频繁促发GC导致内存溢出错误)尽可能地调大年轻代的空间。</p>
<p>还有一个与年轻代相关的调优项”-XX:SurvivorRatio”，该选项用来指定年轻代中对象的生命周期，超过指定时长相关对象将被移至年老代。为了”正确”地设定该值，你需要知道年轻代空间回收的频率，能够估算到新对象在应用程序进程中被引用的时长，同时也取决于分配率。</p>
<p><strong>并发垃圾回收调优</strong></p>
<p>针对对停顿敏感的应用，建议使用并发垃圾回收，虽然并行的办法能够带来非常好的吞吐量基准测试分数，但是并行GC不利于缩短响应时间。并发 GC 是目前唯一有效的实现一致性和最少“stop the world”中断的方法。不同的JVM提供不同的并发GC的设定，Oracle JVM(hotspot)提供”-XX:+UseConcMarkSweepGC”,今后G1将成为Oracle JVM默认的并发垃圾回收器。</p>
<p><strong>性能调优并不是真正的解决办法</strong></p>
<p>或许你已经注意到上文中在讨论如何“正确“地设定调优此参数时，我刻意在”正确“二字上加了双引号。那是因为就我个人经验而言一旦涉及到性能参数调优，就没有严格意义上的正确设定。每一个设定值都是针对特定的场景。考虑到应用场景会发生变化，JVM 性能调整充其量是一个权宜之计。</p>
<p>以堆的设置为例：如果2GB的堆可以应对20万并发用户，但是可能不能应付40万的并发用户。</p>
<p>我们再以”-XX:SurvivorRatio”为例：当设定符合一个负载持续增长最高至每毫秒10000个交易的场景，当压力到达每毫秒50000个交易时又会发生什么呢？</p>
<p>大多数企业级应用负载都是动态的，Java语言的动态内存管理以及动态编译等技术使得Java更加适合企业级应用。我们来看看一下两个配置清单。</p>
<p>清单1. 应用程序(1)的启动选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;java -Xmx12g -XX:MaxPermSize=<span class="number">64</span>M -XX:PermSize=<span class="number">32</span>M -XX:MaxNewSize=<span class="number">2</span>g </span><br><span class="line">-XX:NewSize=<span class="number">1</span>g -XX:SurvivorRatio=<span class="number">16</span> -XX:+UseParNewGC </span><br><span class="line">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=<span class="number">0</span> </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=<span class="number">60</span> -XX:+CMSParallelRemarkEnabled </span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly -XX:ParallelGCThreads=<span class="number">12</span> </span><br><span class="line">-XX:LargePageSizeInBytes=<span class="number">256</span>m …</span><br></pre></td></tr></table></figure>
<p>清单2. 应用程序(2)的启动选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;java --Xms8g --Xmx8g --Xmn2g -XX:PermSize=<span class="number">64</span>M -XX:MaxPermSize=<span class="number">256</span>M </span><br><span class="line">-XX:-OmitStackTraceInFastThrow -XX:SurvivorRatio=<span class="number">2</span> -XX:-UseAdaptiveSizePolicy -XX:+UseConcMarkSweepGC </span><br><span class="line">-XX:+CMSConcurrentMTEnabled -XX:+CMSParallelRemarkEnabled -XX:+CMSParallelSurvivorRemarkEnabled </span><br><span class="line">-XX:CMSMaxAbortablePrecleanTime=<span class="number">10000</span> -XX:+UseCMSInitiatingOccupancyOnly </span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=<span class="number">63</span> -XX:+UseParNewGC --Xnoclassgc …</span><br></pre></td></tr></table></figure>
<p>两者的配置区别很大，因为他们是两个不同应用程序。感觉根据各自的应用特设都做了”正确“的配置与调优。在实验室环境下都运行良好，但在生产环境中最终会表现出疲态。清单1由于没有考虑到动态负载，到了生产环境即表现不良。清单2没有考虑到应用程序在生产环境中的特性变化。这两种情况应该归咎于开发团队，但是该归咎于何处呢？</p>
<p><strong>变通办法可行吗？</strong></p>
<p>有些企业通过精确测量交易对象的大小定义极致的对象回收空间并”精简“其架构来适配该空间。这也许是办法来削减碎片以应对一整天的交易(在不做堆压缩的情况下)。还有一个办法就是通过程序设计确保对象被引用的时间在一个比较短的时间内从而阻止其在SurvivorRatio时间之后不被迁往年老代而直接被回收，避免内存压缩的场景。这两种办法都可以，但是对应用开发人员和设计人员有一定的挑战。</p>
<p><strong>谁保障应用程序的性能？</strong></p>
<p>一个门户应用可能会在其活动负载峰值点出现故障；一个交易应用可能会在每次市场下跌和上升时无法正常运行；电子商务网站可能会无法应对节假日购物高峰期。这些都是真实世界的案例基本都是JVM性能参数调优导致的。当产生了经济损失，开发团队就会受到责备。也许某些场合下开发团队应该要受到责备，但是JVM的提供商又应该负起什么样儿的责任呢？</p>
<p>首先JVM提供商应该要提供调优参数的优先顺序，至少这在短期内还是很有意义的。有一些新的调优选项是针对特定的、 新兴的企业应用程序场景。更多的调优选项是为了减轻JVM支持团队的工作负荷而将性能优化转嫁到应用开发者身上。但我个人认为这或将导致更加漫长的支持负荷，一些针对最糟糕场景的调优选项也将被延期，当然不是无限延期。</p>
<p>毋庸置疑JVM的开发团队也在努力地进行着他们的工作，同时也只有应用实施者才会更加清楚他们应用的特定需求。但是应用的实施者或开发者是无法预测期动态的负载需求。在过去，JVM提供商也会去分析关于Java的性能与可扩展性问题，哪些是他们能够解决的。不是提供调优参数，而是直接去优化或创新垃圾回收的算法。更有趣是我们可以想象一下如果OpenJDK的社区聚集在一起重新考虑Java垃圾回收器将会发生什么！</p>
<p><strong>JVM**</strong>性能的基准测试**</p>
<p>调优参数有时被JVM提供商作为其竞争的工具，因为不同的调优可以改善他们的JVM在可预见的环境中的性能表现，本系列的最后一片文章中将调查这些基准测试来衡量JVM的性能。</p>
<p><strong>JVM**</strong>开发者的挑战**</p>
<p>真正的企业级可伸缩性需求是要求JVM能够适应动态灵活的应用负载。这是在特定吞吐量和响应时间内保证持续稳定性能的关键。这是JVM开发者才能完成历史使命，因此是时候号召我们Java开发者社区来迎接真正的Java可伸缩性的挑战。</p>
<ul>
<li>持续调优</li>
</ul>
<p>对于给定的应用，在一开始需要告知其需要多大的内存，之后的工作都应该有JVM来负责 ，JVM需要适配动态的应用负载和运行场景。</p>
<ul>
<li>JVM实例数 vs. 实例的可扩展性</li>
</ul>
<p>现在的服务器都支持很大的内存，那么为什么JVM实例不能有效地利用它呢？将应用拆分部署许多小的应用服务器实例上，这从经济和环保角度都是一种浪费。现代的JVM需要跟上硬件和应用的发展潮流。</p>
<ul>
<li>真实世界的性能和可伸缩性</li>
</ul>
<p>企业不需要为其应用的性能需求去做极致的性能调优。JVM提供商和OpenJDK社区需要去解决Java可伸缩性的核心问题以及消除“stop the world“的操作。</p>
<p><strong>结论</strong></p>
<p>如果JVM做了这样的工作，并且提供了并发压缩的垃圾回收算法，JVM也不再成为Java可伸缩性的限制因素，Java应用开发者不需要花费痛苦的时间理解怎样配置JVM去获得最佳性能，从而将会有更多的有趣的Java应用层面的创新，而不是无休止的JVM调优。我要挑战JVM开发人员以及提供商所需要做的事情来相应甲骨文所提倡的“Make the Java Future“的活动。</p>
</div><hr></div><div class="recent-post-item"><a class="article-title" href="/2018/04/28/JVM性能优化， Part 4 ―― C4 垃圾回收/">JVM性能优化， Part 4  ―― C4 垃圾回收</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-28</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/作者：Eva-Andreasson-译者：曹旭东/">作者：Eva Andreasson,译者：曹旭东</a></span><div class="content"><p>本文是JVM性能优化 系列-第4篇。前3篇文章请参考文章结尾处的JVM优化系列文章。作为Eva Andreasson的JVM性能优化系列的第4篇，本文将对C4垃圾回收器进行介绍。使用C4垃圾回收器可以有效提升对低延迟有要求的企业级Java应用程序的伸缩性。</p>
<p>到目前为止，本系列的文章将stop-the-world式的垃圾回收视为影响Java应用程序伸缩性的一大障碍，而伸缩性又是现代企业级Java应用程序开发的基础要求，因此这一问题亟待改善。幸运的是，针对此问题，JVM中已经出现了一些新特性，所使用的方式或是对stop-the-world式的垃圾回收做微调，或是消除冗长的暂停（这样更好些）。在一些多核系统中，内存不再是稀缺资源，因此，JVM的一些新特性就充分利用多核系统的潜在优势来增强Java应用程序的伸缩性。</p>
<p>在本文中，我将着重介绍C4算法，该算法是Azul System公司中无暂停垃圾回收算法的新成果，目前只在Zing JVM上得到实现。此外，本文还将对Oracle公司的G1垃圾回收算法和IBM公司的Balanced Garbage Collection Policy算法做简单介绍。希望通过对这些垃圾回收算法的学习可以扩展你对Java内存管理模型和Java应用程序伸缩性的理解，并激发你对这方面内容的兴趣以便更深入的学习相关知识。至少，你可以学习到在选择JVM时有哪些需要关注的方面，以及在不同应用程序场景下要注意的事项。</p>
<p><strong>C4算法中的并发性</strong></p>
<p>Azul System公司的C4（Concurrent Continuously Compacting Collector，译者注，Azul官网给出的名字是Continuously Concurrent Compacting Collector）算法使用独一无二而又非常有趣的方法来实现低延迟的分代式垃圾回收。相比于大多数分代式垃圾回收器，C4的不同之处在于它认为垃圾回收并不是什么坏事（即应用程序产生垃圾很正常），而压缩是不可避免的。在设计之初，C4就是要牺牲各种动态内存管理的需求，以满足需要长时间运行的服务器端应用程序的需求。</p>
<p>C4算法将释放内存的过程从应用程序行为和内存分配速率中分离出来，并加以区分。这样就实现了并发运行，即应用程序可以持续运行，而不必等待垃圾回收的完成。其中的并发性是关键所在，正是由于并发性的存在才可以使暂停时间不受垃圾回收周期内堆上活动数据数量和需要跟踪与更新的引用数量的影响，将暂停时间保持在较低的水平。正如我在本系列<a href="https://github.com/chiyuanbo/cyb-mds/blob/master/java/jvm/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%203%20%20%E2%80%95%E2%80%95%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" target="_blank" rel="noopener">第3篇</a>中介绍的一样，大多数垃圾回收器在工作周期内都包含了stop-the-world式的压缩过程，这就是说应用程序的暂停时间会随活动数据总量和堆中对象间引用的复杂度的上升而增加。使用C4算法的垃圾回收器可以并发的执行压缩操作，即压缩与应用程序线程同时工作，从而解决了影响JVM伸缩性的最大难题。</p>
<p>实际上，为了实现并发性，C4算法改变了现代Java企业级架构和部署模型的基本假设。想象一下拥有数百GB内存的JVM会是什么样的：</p>
<ul>
<li>部署Java应用程序时，对伸缩性的要求无需要多个JVM配合，在单一JVM实例中即可完成。这时的部署是什么样呢？</li>
<li>有哪些以往因GC限制而无法在内存存储的对象？</li>
<li>那些分布式集群（如缓存服务器、区域服务器，或其他类型的服务器节点）会有什么变化？当可以增加JVM内存而不会对应用程序响应时间造成负面影响时，传统的节点数量、节点死亡和缓存丢失的计算会有什么变化呢？</li>
</ul>
<p><strong>C4算法的3的阶段</strong></p>
<p>C4算法的一个基本假设是“垃圾回收不是坏事”和“压缩不可避免”。C4算法的设计目标是实现垃圾回收的并发与协作，剔除stop-the-world式的垃圾回收。C4垃圾回收算法包含一下3个阶段：</p>
<ol>
<li><em>标记（Marking）</em> — 找到活动对象</li>
<li><em>重定位（Relocation）</em> — 将存活对象移动到一起，以便可以释放较大的连续空间，这个阶段也可称为“压缩（compaction）”</li>
<li><em>重映射（Remapping）</em> — 更新被移动的对象的引用。</li>
</ol>
<p>下面的内容将对每个阶段做详细介绍。</p>
<p><strong>C4算法中的标记阶段</strong></p>
<p>在C4算法中，<em>标记阶段（marking phase）</em>使用了<em>并发标记（concurrent marking）</em>和引用跟踪<em>（reference-tracing）</em>的方法来标记活动对象，这方面内容已经在本系列的<a href="https://github.com/chiyuanbo/cyb-mds/blob/master/java/jvm/JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%8C%20Part%203%20%20%E2%80%95%E2%80%95%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" title="Collection" target="_blank" rel="noopener">第3篇</a>中介绍过。</p>
<p>在标记阶段中，GC线程会从线程栈和寄存器中的活动对象开始，遍历所有的引用，标记找到的对象，这些GC线程会遍历堆上所有的可达（reachable）对象。在这个阶段，C4算法与其他并发标记器的工作方式非常相似。</p>
<p>C4算法的标记器与其他并发标记器的区别也是始于并发标记阶段的。在并发标记阶段中，如果应用程序线程修改未标记的对象，那么该对象会被放到一个队列中，以备遍历。这就保证了该对象最终会被标记，也因为如此，C4垃圾回收器或另一个应用程序线程不会重复遍历该对象。这样就节省了标记时间，消除了递归重标记（recursive remark）的风险。（注意，长时间的递归重标记有可能会使应用程序因无法获得足够的内存而抛出OOM错误，这也是大部分垃圾回收场景中的普遍问题。）</p>
<p><a href="http://www.importnew.com/?attachment_id=2411" target="_blank" rel="noopener"><img src="http://www.importnew.com/wp-content/uploads/2013/01/jvmseries4-fig1-300x164.png" alt="" title="jvmseries4-fig1"></a></p>
<p>Figure 1. Application threads traverse the heap just once during marking</p>
<p>如果C4算法的实现是基于脏卡表（dirty-card tables）或其他对已经遍历过的堆区域的读写操作进行记录的方法，那垃圾回收线程就需要重新访问这些区域做重标记。在极端条件下，垃圾回收线程会陷入到永无止境的重标记中 —— 至少这个过程可能会长到使应用程序因无法分配到新的内存而抛出OOM错误。但C4算法是基于<em>LVB（load value barrier）</em>实现的，LVB具有自愈能力，可以使应用程序线程迅速查明某个引用是否已经被标记过了。如果这个引用没有被标记过，那么应用程序会将其添加到GC队列中。一旦该引用被放入到队列中，它就不会再被重标记了。应用程序线程可以继续做它自己的事。</p>
<p><em>脏对象（dirty object）和卡表（card table）</em><br>由于某些原因（例如在一个并发垃圾回收周期中，对象被修改了），垃圾回收器需要重新访问某些对象，那么这些对象<em>脏对象（dirty object）</em>。这这些脏对象，或堆中脏区域的引用，通过会记录在一个专门的数据结构中，这就是卡表。</p>
<p>在C4算法中，并没有重标记（re-marking）这个阶段，在第一次便利整个堆时就会将所有可达对象做标记。因为运行时不需要做重标记，也就不会陷入无限循环的重标记陷阱中，由此而降低了应用程序因无法分配到内存而抛出OOM错误的风险。</p>
<p><strong>C4算法中的重定位 ——　应用程序线程与GC的协作</strong></p>
<p>C4算法中，<em>重定位阶段（reloacation phase）</em>是由GC线程和应用程序线程以协作的方式，并发完成的。这是因为GC线程和应用程序线程会同时工作，而且无论哪个线程先访问将被移动的对象，都会以协作的方式帮助完成该对象的移动任务。因此，应用程序线程可以继续执行自己的任务，而不必等待整个垃圾回收周期的完成。</p>
<p>正如Figure 2所示，碎片内存页中的活动对象会被重定位。在这个例子中，应用程序线程先访问了要被移动的对象，那么应用程序线程也会帮助完成移动该对象的工作的初始部分，这样，它就可以很快的继续做自己的任务。虚拟地址（指相关引用）可以指向新的正确位置，内存也可以快速回收。</p>
<p><a href="http://www.importnew.com/2410.html/jvmseries4-fig2" target="_blank" rel="noopener"><img src="http://www.importnew.com/wp-content/uploads/2013/01/jvmseries4-fig2-300x169.png" alt="" title="jvmseries4-fig2"></a></p>
<p>Figure 2. A page selected for relocation and the empty new page that it will be moved to</p>
<p>如果是GC线程先访问到了将被移动的对象，那事情就简单多了，GC线程会执行移动操作的。如果在重映射阶段（re-mapping phase，后续会提到）也访问这个对象，那么它必须检查该对象是否是要被移动的。如果是，那么应用程序线程会重新定位这个对象的位置，以便可以继续完成自己任务。（对大对象的移动是通过将该对象打碎再移动完成的。如果你对这部分内容感兴趣的话，推荐你阅读一下相关资源中的这篇白皮书“C4: The Continuously Concurrent Compacting Collector”）</p>
<p>当所有的活动对象都从某个内存也中移出后，剩下的就都是垃圾数据了，这个内存页也就可以被整体回收了。正如Figure 2中所示。</p>
<p><em>关于清理</em><br>在C4算法中并没有清理阶段（sweep phase），因此也就不需要这个在大多数垃圾回收算法中比较常用的操作。在指向被移动的对象的引用都更新为指向新的位置之前，from页中的虚拟地址空间必须被完整保留。所以C4算法的实现保证了，在所有指向这个页的引用处于稳定状态前，所有的虚拟地址空间都会被锁定。然后，算法会立即回收物理内存页。</p>
<p>很明显，无需执行stop-the-world式的移动对象是有很大好处的。由于在重定位阶段，所有活动对象都是并发移动的，因此它们可以被更有效率的放入到相邻的地址中，并且可以充分的压缩。通过并发执行重定位操作，堆被压缩为连续空间，也无需挂起所有的应用程序线程。这种方式消除了Java应用程序访问内存的传统限制（更多关于Java应用程序内存模型的内容参见ImportNew编译整理的第一篇《<a href="http://www.importnew.com/1774.html" target="_blank" rel="noopener">JVM性能优化， Part 1 ―― JVM简介</a>》）。</p>
<p>经过上述的过程后，如何更新引用呢？如何实现一个非stop-the-world式的操作呢？</p>
<p><strong>C4算法中的重映射</strong></p>
<p>在重定位阶段，某些指向被移动的对象的引用会自动更新。但是，在重定位阶段，那些指向了被移动的对象的引用并没有更新，仍然指向原处，所以它们需要在后续完成更新操作。C4算法中的<em>重映射阶段（re-mapping phase）</em>负责完成对那些活动对象已经移出，但仍指向那些的引用进行更新。当然，重映射也是一个协作式的并发操作。</p>
<p>Figure 3中，在重定位阶段，活动对象已经被移动到了一个新的内存页中。在重定位之后，GC线程立即开始更新那些仍然指向之前的虚拟地址空间的引用，将它们指向那些被移动的对象的新地址。垃圾回收器会一直执行此项任务，直到所有的引用都被更新，这样原先虚拟内存空间就可以被整体回收了。</p>
<p><a href="http://www.importnew.com/2410.html/jvmseries4-fig3" target="_blank" rel="noopener"><img src="http://www.importnew.com/wp-content/uploads/2013/01/jvmseries4-fig3-300x188.png" alt="" title="jvmseries4-fig3"></a></p>
<p>Figure 3. Whatever thread finds an invalid address enables an update to the correct new address</p>
<p>但如果在GC完成对所有引用的更新之前，应用程序线程想要访问这些引用的话，会出现什么情况呢？在C4算法中，应用程序线程可以很方便的帮助完成对引用进行更新的工作。如果在重映射阶段，应用程序线程访问了处于非稳定状态的引用，它会找到该引用的正确指向。如果应用程序线程找到了正确的引用，它会更新该引用的指向。当完成更新后，应用程序线程会继续自己的工作。</p>
<p>协作式的重映射保证了引用只会被更新一次，该引用下的子引用也都可以指向正确的新地址。此外，在大多数其他GC实现中，引用指向的地址不会被存储在该对象被移动之前的位置；相反，这些地址被存储在一个堆外结构（off-heap structure）中。这样，无需在对所有引用的更新完成之前，再花费精力保持整个内存页完好无损，这个内存页可以被整体回收。</p>
<p><strong>C4算法真的是无暂停的么？</strong></p>
<p>在C4算法的重映射阶段，正在跟踪引用的线程仅会被中断一次，而这次中断仅仅会持续到对该引用的检索和更新完成，在这次中断后，线程会继续运行。相比于其他并发算法来说，这种实现会带来巨大的性能提升，因为其他的并发立即回收算法需要等到每个线程都运行到一个安全点（safe point），然后同时挂起所有线程，再开始对所有的引用进行更新，完成后再恢复所有线程的运行。</p>
<p>对于并发压缩垃圾回收器来说，由于垃圾回收所引起的暂停从来都不是问题。在C4算法的重定位阶段中，也不会有再出现更糟的碎片化场景了。实现了C4算法的垃圾回收器也不会出现背靠背（back-to-back）式的垃圾回收周期，或者是因垃圾回收而使应用程序暂停数秒甚至数分钟。如果你曾经体验过这种stop-the-world式的垃圾回收，那么很有可能是你给应用程序设置的内存太小了。你可以试用一下实现了C4算法的垃圾回收器，并为其分配足够多的内存，而完全不必担心暂停时间过长的问题。</p>
<p><strong>评估C4算法和其他可选方案</strong></p>
<p>像往常一样，你需要针对应用程序的需求选择一款JVM和垃圾回收器。C4算法在设计之初就是无论堆中活动数据有多少，只要应用程序还有足够的内存可用，暂停时间都始终保持在较低的水平。正因如此，对于那些有大量内存可用，而对响应时间比较敏感的应用程来说，选择实现了C4算法的垃圾回收器正是不二之选。</p>
<p>而对于那些要求快速启动，内存有限的客户端应用程序来说，C4就不是那么适用。而对于那些对吞吐量有较高要求的应用程序来说，C4也并不适用。真正能够发挥C4威力的是那些为了提升应用程序工作负载而在每台服务器上部署了4到16个JVM实例的场景。此外，如果你经常要对垃圾回收器做调优的话，那么不妨考虑一下使用C4算法。综上所述，当响应时间比吞吐量占有更高的优先级时，C4是个不错的选择。而对那些不能接受长时间暂停的应用程序来说，C4是个理想的选择。</p>
<p>如果你正考虑在生产环境中使用C4，那么你可能还需要重新考虑一下如何部署应用程序。例如，不必为每个服务器配置16个具有2GB堆的JVM实例，而是使用一个64GB的JVM实例（或者增加一个作为热备份）。C4需要尽可能大的内存来保证始终有一个空闲内存页来为新创建的对象分配内存。（记住，内存不再是昂贵的资源了！）</p>
<p>如果你没有64GB，128GB，或1TB（或更多）内存可用，那么分布式的多JVM部署可能是一个更好的选择。在这种场景中，你可以考虑使用Oracle HotSpot JVM的G1垃圾回收器，或者IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）。下面将对这两种垃圾回收器做简单介绍。</p>
<p><strong>Gargabe-First （G1） 垃圾回收器</strong></p>
<p>G1垃圾回收器是新近才出现的垃圾回收器，是Oracle HotSpot JVM的一部分，在最近的JDK1.6版本中首次出现（译者注，该文章写于2012-07-11）。在启动Oracle JDK时附加命令行选项<em>-XX:+UseG1GC</em>，可以启动G1垃圾回收器。</p>
<p>与C4类似，这款标记-清理（mark-and-sweep）垃圾回收器也可作为对低延迟有要求的应用程序的备选方案。G1算法将堆分为固定大小区域，垃圾回收会作用于其中的某些区域。在应用程序线程运行的同时，启用后台线程，并发的完成标记工作。这点与其他并发标记算法相似。</p>
<p>G1增量方法可以使暂停时间更短，但更频繁，而这对一些力求避免长时间暂停的应用程序来说已经足够了。另一方面，正如在本系列的[Part 3][4]中介绍的，使用G1垃圾回收器需要针对应用程序的实际需求做长时间的调优，而其GC中断又是stop-the-world式的。所以对那些对低延迟有很高要求的应用程序来说，G1并不是一个好的选择。进一步说，从暂停时间总长来看，G1长于CMS（Oracle JVM中广为人知的并发垃圾回收器）。</p>
<p>G1使用拷贝算法（在Part 3中介绍过）完成部分垃圾回收任务。这样，每次垃圾回收器后，都会产生完全可用的空闲空间。G1垃圾回收器定义了一些区域的集合作为年轻代，剩下的作为老年代。</p>
<p>G1已经吸引了足够多的注意，引起了不小的轰动，但是它真正的挑战在于如何应对现实世界的需求。正确的调优就是其中一个挑战 —— 回忆一下，对于动态应用程序负载来说，没有永远“正确的调优”。一个问题是如何处理与分区大小相近的大对象，因为剩余的空间会成为碎片而无法使用。还有一个性能问题始终困扰着低延迟垃圾回收器，那就是垃圾回收器必须管理额外的数据结构。就我来说，使用G1的关键问题在于如何解决stop-the-world式垃圾回收器引起的暂停。Stop-the-world式的垃圾回收引起的暂停使任何垃圾回收器的能力都受制于堆大小和活动数据数量的增长，对企业级Java应用程序的伸缩性来说是一大困扰。</p>
<p><strong>IBM JVM的平衡垃圾回收策略（Balanced Garbage Collection Policy）</strong></p>
<p>IBM JVM的平衡垃圾回收（Balanced Garbage Collection BGC）策略通过在启动IBM JDK时指定命令行选项<em>-Xgcpolicy:balanced</em>来启用。乍一看，BGC很像G1，它也是将Java堆划分成相同大小的空间，称为区间（region），执行垃圾回收时会对每个区间单独回收。为了达到最佳性能，在选择要执行垃圾回收的区间时使用了一些启发性算法。BGC中关于代的划分也与G1相似。</p>
<p>IBM的平衡垃圾回收策略仅在64位平台得到实现，是一种NUMA架构（Non-Uniform Memory Architecture），设计之初是为了用于具有4GB以上堆的应用程序。由于拷贝算法或压缩算法的需要，BGC的部分垃圾回收工作是stop-the-world式的，并非完全并发完成。所以，归根结底，BGC也会遇到与G1和其他没有实现并发压缩选法的垃圾回收器相似的问题。</p>
<p><strong>结论：回顾</strong></p>
<p>C4是基于引用跟踪的、分代式的、并发的、协作式垃圾回收算法，目前只在Azul System公司的Zing JVM得到实现。C4算法的真正价值在于：</p>
<ul>
<li>消除了重标记可能引起的重标记无限循环，也就消除了在标记阶段出现OOM错误的风险。</li>
<li>压缩，以自动、且不断重定位的方式消除了固有限制：堆中活动数据越多，压缩所引起的暂停越长。</li>
<li>垃圾回收不再是stop-the-world式的，大大降低垃圾回收对应用程序响应时间造成的影响。</li>
<li>没有了清理阶段，降低了在完成GC之前就因为空闲内存不足而出现OOM错误的风险。</li>
<li>内存可以以页为单位立即回收，使那些需要使用较多内存的Java应用程序有足够的内存可用。</li>
</ul>
<p>并发压缩是C4独一无二的优势。使应用程序线程GC线程协作运行，保证了应用程序不会因GC而被阻塞。C4将内存分配和提供足够连续空闲内存的能力完全区分开。C4使你可以为JVM实例分配尽可能大的内存，而无需为应用程序暂停而烦恼。使用得当的话，这将是JVM技术的一项革新，它可以借助于当今的多核、TB级内存的硬件优势，大大提升低延迟Java应用程序的运行速度。</p>
<p>如果你不介意一遍又一遍的调优，以及频繁的重启的话，如果你的应用程序适用于水平部署模型的话（即部署几百个小堆JVM实例而不是几个大堆JVM实例），G1也是个不错的选择。</p>
<p>对于动态低延迟启发性自适应（dynamic low-latency heuristic adaption）算法而言，BGC是一项革新，JVM研究者对此算法已经研究了几十年。该算法可以应用于较大的堆。而动态自调优算法（ dynamic self-tuning algorithm）的缺陷是，它无法跟上突然出现的负载高峰。那时，你将不得不面对最糟糕的场景，并根据实际情况再分配相关资源。</p>
<p>最后，为你的应用程序选择最适合的JVM和垃圾回收器时，最重要的考虑因素是应用程序中吞吐量和暂停时间的优先级次序。你想把时间和金钱花在哪？从纯粹的技术角度说，基于我十年来对垃圾回收的经验，我一直在寻找更多关于并发压缩的革新性技术，或其他可以以较小代价完成移动对象或重定位的方法。我想影响企业级Java应用程序伸缩性的关键就在于并发性。</p>
<p><strong>JVM 性能优化系列</strong></p>
<p>第一篇 《<a href="http://www.importnew.com/1774.html" target="_blank" rel="noopener">JVM性能优化， Part 1 ―― JVM简介</a> 》</p>
<p>第二篇《<a href="http://www.importnew.com/2009.html" target="_blank" rel="noopener">JVM性能优化， Part 2 ―― 编译器</a>》</p>
<p><strong>第三篇<a href="http://www.importnew.com/2233.html" target="_blank" rel="noopener">《JVM性能优化， Part 3 —— 垃圾回收》</a></strong></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By YB-Chi</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script><script src="/js/search/local-search.js"></script></body></html>